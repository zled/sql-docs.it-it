---
title: Guida di riferimento a operatori Showplan logici e fisici | Microsoft Docs
ms.custom: 
ms.date: 05/31/2017
ms.prod: sql-server-2016
ms.reviewer: 
ms.suite: 
ms.technology:
- database-engine
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- sql13.swb.showplan.leftouterjoin.f1
- sql13.swb.showplan.remotedelete.f1
- sql13.swb.showplan.parallelism.f1
- sql13.swb.showplan.indexspool.f1
- sql13.swb.showplan.result.f1
- sql13.swb.showplan.bitmapcreate.f1
- sql13.swb.showplan.remotescan.f1
- sql13.swb.showplan.union.f1
- sql13.swb.showplan.bitmap.f1
- sql13.swb.showplan.RIDLookup
- sql13.swb.showplan.innerjoin.f1
- sql13.swb.showplan.dynamic.f1
- sql13.swb.showplan.distributestreams.f1
- sql13.swb.showplan.clusteredindexdelete.f1
- sql13.swb.showplan.keylookup.f1
- sql13.swb.showplan.partialaggregate.f1
- sql13.swb.showplan.distinctsort.f1
- sql13.swb.showplan.collapse.f1
- sql13.swb.showplan.print.f1
- sql13.swb.showplan.crossjoin.f1
- sql13.swb.showplan.convert.f1
- sql13.swb.showplan.split.f1
- sql13.swb.showplan.top.f1
- sql13.swb.showplan.update.f1
- sql13.swb.showplan.keyset.f1
- sql13.swb.showplan.fetchquery.f1
- sql13.swb.showplan.mergejoin.f1
- sql13.swb.showplan.branchrepartition.f1
- sql13.swb.showplan.tableinsert.f1
- sql13.swb.showplan.clusteredindexseek.f1
- sql13.swb.showplan.indexupdate.f1
- sql13.swb.showplan.indexinsert.f1
- sql13.swb.showplan.clusteredindexupdate.f1
- sql13.swb.showplan.streamaggregate.f1
- sql13.swb.showplan.columnstoreindexdelete.f1
- sql13.swb.showplan.snapshot.f1
- sql13.swb.showplan.remotequery.f1
- sql13.swb.showplan.constantscan.f1
- sql13.swb.showplan.rank.f1
- sql13.swb.showplan.rightsemijoin.f1
- sql13.swb.showplan.delete.f1
- sql13.swb.showplan.sequence.f1
- sql13.swb.showplan.locate.f1
- sql13.swb.showplan.aggregate.f1
- sql13.swb.showplan.rightouterjoin.f1
- sql13.swb.showplan.columnstoreindexupdate.f1
- sql13.swb.showplan.clusteredindexinsert.f1
- sql13.swb.showplan.rowcountspool.f1
- sql13.swb.showplan.columnstoreindexscan.f1
- sql13.swb.showplan.leftantisemijoin.f1
- sql13.swb.showplan.sort.f1
- sql13.swb.showplan.leftsemijoin.f1
- sql13.swb.showplan.columnstoreindexinsert.f1
- sql13.swb.showplan.indexscan.f1
- sql13.swb.showplan.columnstoreindexmerge.f1
- sql13.swb.showplan.lazyspool.f1
- sql13.swb.showplan.rightantisemijoin.f1
- sql13.swb.showplan.bookmarklookup.f1
- sql13.swb.showplan.remoteinsert.f1
- sql13.swb.showplan.intrinsic.f1
- sql13.swb.showplan.arithmeticexpression.f1
- sql13.swb.showplan.populationquery.f1
- sql13.swb.showplan.filter.f1
- sql13.swb.showplan.if.f1
- sql13.swb.showplan.hashmatchteam.f1
- sql13.swb.showplan.tablevaluedfunction.f1
- sql13.swb.showplan.assign.f1
- sql13.swb.showplan.nestedloops.f1
- sql13.swb.showplan.buildhash.f1
- sql13.swb.showplan.mergeinterval.f1
- sql13.swb.showplan.hashmatch.f1
- sql13.swb.showplan.parametertablescan.f1
- sql13.swb.showplan.tablemerge.f1
- sql13.swb.showplan.switch.f1
- sql13.swb.showplan.sql.f1
- sql13.swb.showplan.repartitionstreams.f1
- sql13.swb.showplan.logrowscan.f1
- sql13.swb.showplan.assert.f1
- sql13.swb.showplan.computescalar.f1
- sql13.swb.showplan.broadcast.f1
- sql13.swb.showplan.indexseek.f1
- sql13.swb.showplan.gatherstreams.f1
- sql13.swb.showplan.remoteindexscan.f1
- sql13.swb.showplan.segment.f1
- sql13.swb.showplan.tableupdate.f1
- sql13.swb.showplan.clusteredindexscan.f1
- sql13.swb.showplan.cache.f1
- sql13.swb.showplan.spool.f1
- sql13.swb.showplan.indexdelete.f1
- sql13.swb.showplan.distinct.f1
- sql13.swb.showplan.deletedscan.f1
- sql13.swb.showplan.eagerspool.f1
- sql13.swb.showplan.hashmatchroot.f1
- sql13.swb.showplan.setfunction.f1
- sql13.swb.showplan.clusteredindexmerge.f1
- sql13.swb.showplan.flowdistinct.f1
- sql13.swb.showplan.tabledelete.f1
- sql13.swb.showplan.tablescan.f1
- sql13.swb.showplan.refreshquery.f1
- sql13.swb.showplan.tablespool.f1
- sql13.swb.showplan.insertedscan.f1
- sql13.swb.showplan.insert.f1
- sql13.swb.showplan.remoteindexseek.f1
- sql13.swb.showplan.fullouterjoin.f1
- sql13.swb.showplan.declare.f1
- sql13.swb.showplan.udx.f1
- sql13.swb.showplan.while.f1
- sql13.swb.showplan.remoteupdate.f1
- sql13.swb.showplan.concatenation.f1
- sql13.swb.showplan.computescalar
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
caps.latest.revision: 51
author: BYHAM
ms.author: rickbyh
manager: jhubbard
ms.translationtype: Human Translation
ms.sourcegitcommit: 3fc2a681f001906cf9e819084679db097bca62c7
ms.openlocfilehash: f9a7d0d8023cac77ef0a2d9e7308a419a4518931
ms.contentlocale: it-it
ms.lasthandoff: 05/31/2017

---
# <a name="showplan-logical-and-physical-operators-reference"></a>Guida di riferimento a operatori Showplan logici e fisici
  Gli operatori descrivono la modalità di esecuzione di una query o di un'istruzione del linguaggio di manipolazione dei dati (DML, Data Manipulation Language) in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] . In Query Optimizer gli operatori consentono di compilare un piano di query per ottenere i risultati specificati nella query o per eseguire l'operazione specificata nell'istruzione DML. Il piano di query è un albero composto da operatori fisici che è possibile visualizzare tramite le istruzioni SET SHOWPLAN, le opzioni del piano di esecuzione grafico in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]o le classi di eventi Showplan di SQL Server Profiler.  
  
 Gli operatori sono suddivisi in operatori logici e fisici.  
  
 **Operatori logici**  
 Gli operatori logici descrivono l'operazione algebrica relazionale utilizzata per elaborare un'istruzione, ovvero descrivono a livello concettuale quale operazione deve essere eseguita.  
  
 **Operatori fisici**  
 Gli operatori fisici implementano l'operazione descritta dagli operatori logici. Ogni operatore fisico è un oggetto o una routine che esegue un'operazione. Alcuni operatori fisici, ad esempio, accedono alle colonne o alle righe di una tabella, di un indice o di una vista, mentre altri eseguono operazioni diverse, ad esempio calcoli, aggregazioni, controlli di integrità dei dati o creazione di join. Gli operatori fisici possono influire sulle prestazioni.  
  
 Dopo essere stati inizializzati, gli operatori fisici raccolgono dati e quindi vengono chiusi. Un operatore fisico risponde alle tre chiamate di metodo seguenti:  
  
-   **Init()**: con la chiamata del metodo **Init()** un operatore fisico si autoinizializza e imposta le strutture di dati necessarie. Sebbene l'operatore fisico possa ricevere molte chiamate **Init()** , in genere ne riceve una sola.  
  
-   **GetNext()**: con la chiamata del metodo **GetNext()** un operatore fisico recupera la prima riga di dati oppure la successiva. L'operatore fisico può ricevere più chiamate **GetNext()** oppure nessuna.  
  
-   **Close()**: con la chiamata del metodo **Close()** un operatore fisico esegue alcune operazioni di eliminazione e viene quindi chiuso automaticamente. Un operatore fisico riceve una sola chiamata del metodo **Close()** .  
  
 Il metodo **GetNext()** restituisce una riga di dati e il numero di chiamate ricevute viene visualizzato come **ActualRows** nell'output Showplan generato usando SET STATISTICS PROFILE ON o SET STATISTICS XML ON. Per altre informazioni su queste opzioni SET, vedere [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](../t-sql/statements/set-statistics-profile-transact-sql.md) e [SET STATISTICS XML &#40;Transact-SQL&#41;](../t-sql/statements/set-statistics-xml-transact-sql.md).  
  
 I conteggi **ActualRebinds** e **ActualRewinds** visualizzati nell'output Showplan fanno riferimento al numero di chiamate al metodo **Init()**. A meno che un operatore non sia nel lato interno di un join ciclico, **ActualRebinds** è uguale a uno e **ActualRewinds** è uguale a zero. Se un operatore si trova nel lato interno di un join ciclico, la somma del numero delle associazioni e dei ripristini dovrebbe essere pari al numero delle righe elaborate nel lato esterno del join. Una riassociazione significa che uno o più parametri correlati del join sono stati modificati e che è necessario rivalutare il lato interno. Un ripristino significa che nessuno dei parametri correlati è stato modificato e che è possibile riutilizzare il set di risultati interno precedente.  
  
 **ActualRebinds** e **ActualRewinds** sono inclusi nell'output Showplan XML generato utilizzando SET STATISTICS XML ON. Vengono popolati esclusivamente per gli operatori **Nonclustered Index Spool**, **Remote Query**, **Row Count Spool**, **Sort**, **Table Spool**e **Table-valued Function** . Anche**ActualRebinds** e **ActualRewinds** possono essere popolati per gli operatori **Assert** e **Filter** quando l'attributo **StartupExpression** è impostato su TRUE.  
  
 Quando **ActualRebinds** e **ActualRewinds** sono inclusi in uno Showplan XML, sono confrontabili con **EstimateRebinds** e **EstimateRewinds**. Quando non sono presenti, il numero di righe stimato (**EstimateRows**) è confrontabile con il numero effettivo di righe (**ActualRows**). Si noti che nell'output grafico effettivo Showplan viene visualizzato zero per le riassociazioni e i ripristini effettivi quando non presenti.  
  
 Un contatore correlato, **ActualEndOfScans**, è disponibile solo quando l'output Showplan viene generato utilizzando SET STATISTICS XML ON. Ogni volta che un operatore fisico raggiunge la fine del proprio flusso di dati, il contatore viene incrementato di uno. Un operatore fisico può raggiungere la fine del proprio flusso di dati, zero, una o più volte. Come per riassociazioni e ripristini, il numero di analisi terminate può essere maggiore di uno se l'operatore si trova nel lato interno di un join ciclico. Il numero di analisi terminate dovrebbe essere minore o uguale alla somma del numero di riassociazioni e ripristini.  
  
## <a name="mapping-physical-and-logical-operators"></a>Mapping di operatori logici e fisici  
 In Query Optimizer viene creato un piano di query che consiste in un albero di operatori logici. Dopo la creazione del piano, viene scelto l'operatore fisico più efficiente per ogni operatore logico. L'operatore fisico che implementerà un operatore logico viene individuato in base al costo.  
  
 In genere un'operazione logica può essere implementata da più operatori fisici. In alcuni casi rari tuttavia anche un operatore fisico può implementare più operazioni logiche.  
  
## <a name="operator-descriptions"></a>Descrizioni dell'operatore  
 In questa sezione vengono descritti gli operatori fisici e logici.  
  
|Icona del piano di esecuzione grafico|Operatore Showplan|Description|  
|-----------------------------------|-----------------------|-----------------|  
|![Icona dell'operatore di Join adattivo](../relational-databases/media/AdaptiveJoin.gif "icona dell'operatore di Join adattivo")|**Join adattivo**|Il **Join adattivo** operatore consente la scelta di un hash join o un metodo di join annidato dei cicli di essere rinviata fino a quando il dopo il primo input è stato analizzato. | 
|Nessuno|**Aggregate**|L'operatore **Aggregate** calcola il valore di un'espressione che include MIN, MAX, SUM, COUNT o AVG. **Aggregate** può essere un operatore logico o fisico.|  
|![Icona dell'operatore Arithmetic Expression](../relational-databases/media/arithmetic-expression-32x-2.gif "Icona dell'operatore Arithmetic Expression")|**Arithmetic Expression**|L'operatore **Arithmetic Expression** calcola un nuovo valore da valori esistenti in una riga. L'operatore**Arithmetic Expression** non viene usato in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Icona dell'operatore Assert](../relational-databases/media/assert-32x.gif "Icona dell'operatore Assert")|**Assert**|L'operatore **Assert** verifica una condizione, ad esempio convalida l'integrità referenziale oppure verifica che una sottoquery scalare restituisca una riga. Per ogni riga di input, l'operatore **Assert** valuta l'espressione nella colonna **Argument** del piano di esecuzione. Se questa espressione restituisce NULL, la riga viene passata tramite l'operatore **Assert** e l'esecuzione della query procede. Se l'operazione restituisce un valore non NULL, verrà generato l'errore appropriato. **Assert** è un operatore fisico.|  
|![Icona dell'elemento di linguaggio Assign](../relational-databases/media/assign-32.gif "Icona dell'elemento di linguaggio Assign")|**Assign**|L'operatore **Assign** assegna il valore di un'espressione o di una costante a una variabile. **Assign** è un elemento di linguaggio.|  
|Nessuno|**Asnyc Concat**|L'operatore **Asnyc Concat** viene usato solo nelle query remote (query distribuite). Ha  *n*  gli elementi figlio e un nodo padre. Alcuni nodi figlio sono normalmente computer remoti che partecipano a una query distribuita. **Asnyc Concat** invia chiamate `open()` simultanee a tutti i figli e quindi applica una mappa di bit a ogni figlio. Per ogni bit che corrisponde a 1, **Async Concat** invia le righe di output al nodo padre su richiesta.|  
|![Icona dell'operatore Bitmap](../relational-databases/media/bitmap-32x.gif "Icona dell'operatore Bitmap")|**Bitmap**|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] usa l'operatore **Bitmap** per implementare l'applicazione di filtri bitmap nei piani di query paralleli. L'applicazione di filtri bitmap velocizza l'esecuzione delle query eliminando le righe con valori di chiave non in grado di produrre record di join prima di passare le righe a un altro operatore, ad esempio l'operatore **Parallelism** . Un filtro bitmap utilizza una rappresentazione compatta di un set di valori da una tabella in una parte dell'albero dell'operatore per filtrare le righe da una seconda tabella in un'altra parte dell'albero. Rimuovendo le righe non necessarie quanto prima nella query, gli operatori successivi hanno meno righe su cui lavorare e le prestazioni complessive della query migliorano. Query Optimizer determina quando un bitmap è sufficientemente selettivo per essere utile e a quali operatori il filtro viene applicato. **Bitmap** è un operatore fisico.|  
|![Icona dell'operatore Bitmap](../relational-databases/media/bitmap-32x.gif "Icona dell'operatore Bitmap")|**Bitmap Create**|L'operatore **Bitmap Create** è visualizzato nell'output Showplan in cui vengono compilate le mappe di bit. **Bitmap Create** è un operatore logico.|  
|![Icona dell'operatore Bookmark Lookup](../relational-databases/media/bookmark-lookup-32x.gif "Icona dell'operatore Bookmark Lookup")|**Bookmark Lookup**|L'operatore **Bookmark Lookup** usa un segnalibro (ID di riga o chiave di clustering) per cercare la riga corrispondente nella tabella o nell'indice cluster. Nella colonna **Argument** è inclusa l'etichetta segnalibro utilizzata per la ricerca della riga nella tabella o nell'indice cluster. La colonna **Argument** contiene inoltre il nome della tabella o dell'indice cluster in cui viene cercata la riga. Se nella colonna **Argument** viene visualizzata la clausola WITH PREFETCH, Query Processor considera ottimale l'uso della prelettura asincrona (read-ahead) per la ricerca di segnalibri nella tabella o nell'indice cluster.<br /><br /> **Bookmark Lookup** non viene utilizzato in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]. **Clustered Index Seek** e **RID Lookup** consentono invece di eseguire la ricerca tramite segnalibro. Tale funzionalità è supportata inoltre dall'operatore **Key Lookup** .|  
|Nessuno|**Branch Repartition**|In un piano di query parallele sono presenti talvolta regioni concettuali di iteratori. È possibile eseguire tutti gli iteratori all'interno di tale regione mediante thread paralleli. Le regioni devono invece essere eseguite in modalità seriale. Alcuni iteratori **Parallelism** all'interno di una singola regione sono denominati **Branch Repartition**. L'operatore **Parallelism** al confine tra due regioni di questo tipo viene denominato **Segment Repartition**. **Branch Repartition** e **Segment Repartition** sono operatori logici.|  
|Nessuno|**Broadcast**|**Trasmissione** ha un nodo figlio e  *n*  nodi padre. **Broadcast** invia le proprie righe di input a più consumer su richiesta. Ogni consumer riceve tutte le righe. Ad esempio, se tutti i consumer rappresentano i lati di un hash join, quindi  *n*  copie delle tabelle hash verranno compilate.|  
|![Icona dell'operatore Build Hash](../relational-databases/media/build-hash.gif "Icona dell'operatore Build Hash")|**Build Hash**|Indica la compilazione di una tabella hash in batch per un indice columnstore con ottimizzazione per la memoria xVelocity.|  
|Nessuno|**Cache**|L'operatore**Cache** è una versione particolare dell'operatore **Spool**  che consente di archiviare solo una riga di dati. L'operatore**Cache** è un operatore logico. **Cache** non è utilizzato in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Icona dell'operatore Clustered Index Delete](../relational-databases/media/clustered-index-delete-32x.gif "Icona dell'operatore Clustered Index Delete")|**Clustered Index Delete**|L'operatore **Clustered Index Delete** elimina righe dall'indice cluster specificato nella colonna Argument del piano di esecuzione della query. Se nella colonna Argument è presente un predicato WHERE:(), vengono eliminate solo le righe conformi al predicato.**Clustered Index Delete** è un operatore fisico.|  
|![Icona dell'operatore Clustered Index Insert](../relational-databases/media/clustered-index-insert-32x.gif "Icona dell'operatore Clustered Index Insert")|**Clustered Index Insert**|L'operatore Showplan **Clustered Index Insert** consente di inserire le righe dell'input generato nell'indice cluster specificato nella colonna Argument. La colonna Argument include inoltre il predicato SET:(), il quale indica il valore su cui è impostata ogni colonna. Se in **Clustered Index Insert** non sono disponibili figli per i valori Insert, la riga inserita verrà recuperata dall'operatore **Insert** stesso.**Clustered Index Insert** è un operatore fisico.|  
|![Icona dell'operatore Clustered Index Merge](../relational-databases/media/clustered-index-merge-32x.gif "Icona dell'operatore Clustered Index Merge")|**Clustered Index Merge**|L'operatore **Clustered Index Merge** applica un flusso di dati di unione a un indice cluster. L'operatore elimina, aggiorna o inserisce righe dall'indice cluster specificato nella colonna ****  dell'argomento dell'operatore. L'operazione effettiva eseguita dipende dal valore di runtime della colonna **ACTION** specificato nella colonna **Argument** dell'operatore. **Clustered Index Merge** è un operatore fisico.|  
|![Icona dell'operatore Clustered Index Scan](../relational-databases/media/clustered-index-scan-32x.gif "Icona dell'operatore Clustered Index Scan")|**Clustered Index Scan**|L'operatore **Clustered Index Scan** esegue l'analisi dell'indice cluster specificato nella colonna Argument del piano di esecuzione della query. In presenza di un predicato facoltativo WHERE:(), vengono restituite solo le righe conformi al predicato. Se la colonna Argomento include la clausola ORDERED, Query Processor ha richiesto la restituzione dell'output delle righe nell'ordine utilizzato dall'indice cluster. Se la clausola ORDERED non è presente, il motore di archiviazione esegue l'analisi dell'indice in modo ottimale, senza necessariamente ordinare l'output. **Clustered Index Scan** è un operatore logico e fisico.|  
|![Icona dell'operatore Clustered Index Seek](../relational-databases/media/clustered-index-seek-32x.gif "Icona dell'operatore Clustered Index Seek")|**Clustered Index Seek**|L'operatore **Clustered Index Seek** utilizza le funzionalità di ricerca degli indici per recuperare righe da un indice cluster. La colonna **Argument** include il nome dell'indice cluster usato e il predicato SEEK:(). Il motore di archiviazione utilizza l'indice per elaborare soltanto le righe conformi al predicato SEEK:(). Può inoltre includere un predicato WHERE:() in cui il motore di archiviazione valuta tutte le righe che sono conformi al predicato SEEK:(). Si tratta però di un predicato facoltativo, che non utilizza gli indici per completare l'elaborazione.<br /><br /> Se la colonna dell'argomento ****  include la clausola ORDERED, Query Processor ha determinato che le righe devono essere restituite nello stesso ordine utilizzato dall'indice cluster. Se la clausola ORDERED non è presente, il motore di archiviazione esegue la ricerca nell'indice in modo ottimale, senza necessariamente ordinare l'output. Il mantenimento dell'ordinamento dell'output può dare come risultato un livello di efficienza minore rispetto alla restituzione di output non ordinato. Quando viene visualizzata la parola chiave LOOKUP, è in esecuzione una ricerca tramite segnalibro. In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] e versioni successive la funzionalità di ricerca tramite segnalibro è fornita dall'operatore **Key Lookup** . **Clustered Index Seek** è un operatore logico e fisico.|  
|![Icona dell'operatore Clustered Index Update](../relational-databases/media/clustered-index-update-32x.gif "Icona dell'operatore Clustered Index Update")|**Clustered Index Update**|L'operatore **Clustered Index Update** aggiorna le righe di input nell'indice cluster specificato nella colonna **Argument** . Se è presente un predicato WHERE:(), vengono aggiornate solo le righe conformi al predicato. Se è stato specificato un predicato SET:(), ogni colonna aggiornata viene impostata su tale valore. Se è disponibile un predicato DEFINE:(), vengono elencati i valori definiti da tale operatore. Un riferimento a tali valori può essere presente nella clausola SET o altrove nell'operatore o nella query. **Clustered Index Update** è un operatore logico e fisico.|  
|![Icona dell'operatore Collapse](../relational-databases/media/collapse-32x.gif "Icona dell'operatore Collapse")|**Collapse**|L'operatore **Collapse** ottimizza l'elaborazione degli aggiornamenti. Quando si esegue un aggiornamento, è possibile suddividerlo in un'operazione di eliminazione e un'operazione di inserimento tramite l'operatore **Split** . La colonna **Argument** contiene una clausola GROUP BY:() che specifica un elenco di colonne chiave. Se in Query Processor vengono rilevate righe adiacenti che eliminano e inseriscono gli stessi valori chiave, queste operazioni separate vengono sostituite con una singola operazione di aggiornamento più efficiente. **Collapse** è un operatore logico e fisico.|  
|![Analisi indice Columnstore](../relational-databases/media/columnstoreindexscan.gif "Analisi indice Columnstore")|**Analisi indice Columnstore**|L'operatore **Columnstore Index Scan** esegue l'analisi dell'indice columnstore specificato nella colonna **Argument** del piano di esecuzione della query.|  
|![Icona dell'operatore Compute Scalar](../relational-databases/media/compute-scalar-32x.gif "Icona dell'operatore Compute Scalar")|**Compute Scalar**|L'operatore **Compute Scalar** valuta un'espressione e produce un valore scalare calcolato. Tale valore può essere restituito all'utente e/o utilizzato come riferimento in altre parti della query, ad esempio in un predicato di filtro o di join. **Compute Scalar** è un operatore logico e fisico.<br /><br /> Gli operatori**Compute Scalar** visualizzati negli Showplan generati da SET STATISTICS XML potrebbero non includere l'elemento **RunTimeInformation** . Negli Showplan grafici è possibile che **Actual Rows**, **Actual Rebinds**e **Actual Rewinds** non siano presenti nella finestra **Proprietà** quando l'opzione **Includi piano di esecuzione effettivo** è selezionata in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]. Questo indica che, sebbene questi operatori fossero utilizzati nel piano di query compilato, la loro funzione è stata svolta da altri operatori nel piano di query di run-time. Si noti inoltre che il numero di esecuzioni nell'output di Showplan generato da SET STATISTICS PROFILE equivale alla somma di riassociazioni e ripristini in Showplan generati da SET STATISTICS XML.|  
|![Icona dell'operatore Concatenation](../relational-databases/media/concatenation-32x.gif "Icona dell'operatore Concatenation")|**Concatenation**|L'operatore **Concatenation** esegue l'analisi di più input e restituisce ogni riga sottoposta ad analisi. L'operatore**Concatenation** in genere viene utilizzato per implementare il costrutto [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL. L'operatore fisico **Concatenation** prevede uno o più input e un output e copia le righe dal primo flusso di input nel flusso di output, quindi ripete l'operazione per ogni flusso di input aggiuntivo. **Concatenation** è un operatore logico e fisico.|  
|![Icona dell'operatore Constant Scan](../relational-databases/media/constant-scan-32x.gif "Icona dell'operatore Constant Scan")|**Constant Scan**|L'operatore **Constant Scan** inserisce una o più righe con valore costante in una query. Per aggiungere colonne a una riga creata dall'operatore **Constant Scan** viene spesso utilizzato un operatore **Compute Scalar** dopo un operatore **Constant Scan** .|  
|![Icona dell'elemento di linguaggio Convert (motore di database)](../relational-databases/media/convert-32x.gif "Icona dell'elemento di linguaggio Convert (motore di database)")|**Converti**|L'operatore **Convert** converte un tipo di dati scalare in un altro. **Convert** è un elemento di linguaggio.|  
|Nessuno|**Cross Join**|L'operatore **Cross Join** crea un join tra ogni riga del primo input (superiore) e ogni riga del secondo input (inferiore). **Cross Join** è un operatore logico.|  
|![Icona generica dell'operatore Cursor](../relational-databases/media/cursor-catch-all.gif "Icona generica dell'operatore Cursor")|**catchall**|L'icona generica viene visualizzata quando la logica che produce Showplan grafici non è in grado di individuare un'icona appropriata per l'iteratore. L'icona generica non indica necessariamente una condizione di errore. Sono disponibili tre icone generiche: blu (per gli iteratori), arancione (per i cursori) e verde (per gli elementi del linguaggio [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|Nessuno|**Cursore**|Gli operatori logici e fisici **Cursor** consentono di descrivere le modalità di esecuzione di una query o di un aggiornamento che implicano operazioni con i cursori. Gli operatori fisici descrivono l'algoritmo di implementazione fisica utilizzato per l'elaborazione del cursore, ad esempio l'utilizzo di un cursore gestito da keyset. Ogni passaggio dell'esecuzione di un cursore implica un operatore fisico. Gli operatori logici descrivono una proprietà del cursore, ad esempio la proprietà di sola lettura.<br /><br /> Gli operatori logici includono Asynchronous, Optimistic, Primary, Read Only, Scroll Locks e Secondary and Synchronous,<br /><br /> mentre quelli fisici includono Dynamic, Fetch Query, Keyset, Population Query, Refresh Query e Snapshot.|  
|![Icona dell'elemento di linguaggio Declare](../relational-databases/media/declare-32x.gif "Icona dell'elemento di linguaggio Declare")|**Declare**|L'operatore **Declare**  alloca una variabile locale nel piano di query. **Declare** è un elemento di linguaggio.|  
|![Icona dell'operatore Delete (motore di database)](../relational-databases/media/delete-32x.gif "Icona dell'operatore Delete (motore di database)")|**Elimina**|L'operatore **Delete** elimina da un oggetto le righe conformi al predicato facoltativo presente nella colonna **Argument** .|  
|![Icona dell'operatore Deleted Scan](../relational-databases/media/delete-scan-32x.gif "Icona dell'operatore Deleted Scan")|**Deleted Scan**|L'operatore **Deleted Scan** esegue l'analisi della tabella eliminata all'interno di un trigger.|  
|Nessuno|**Distinct**|L'operatore **Distinct** rimuove i duplicati da un set di righe o da una raccolta di valori. **Distinct** è un operatore logico.|  
|Nessuno|**Distinct Sort**|L'operatore logico **Distinct Sort** esegue l'analisi dell'input rimuovendo i valori duplicati ed eseguendo l'ordinamento in base alle colonne specificate nel predicato DISTINCT ORDER BY:() della colonna **Argument** . **Distinct Sort** è un operatore logico.|  
|![Icona dell'operatore di parallelismo Distribute Streams](../relational-databases/media/parallelism-distribute-stream.gif "Icona dell'operatore di parallelismo Distribute Streams")|**Distribute Streams**|L'operatore **Distribute Streams** viene utilizzato esclusivamente in piani di query parallele. L'operatore **Distribute Streams** elabora un singolo flusso di input di record e produce più flussi di output. Il contenuto e il formato del record non vengono modificati. Ogni record del flusso di input appare in uno dei flussi di output. L'operatore mantiene automaticamente l'ordine relativo dei record di input nei flussi di output. In genere, l'appartenenza di un record di input a un flusso di output viene determinata tramite un'operazione di hashing.<br /><br /> Se l'output è partizionato, la colonna **Argument** include un predicato PARTITION COLUMNS:() e le colonne di partizionamento. **Distribute Streams** è un operatore logico.|  
|![Icona dell'operatore Dynamic per il cursore](../relational-databases/media/dynamic-32x.gif "Icona dell'operatore Dynamic per il cursore")|**Dynamic**|L'operatore **Dynamic** utilizza un cursore che può visualizzare tutte le modifiche apportate da altri utenti.|  
|![Icona dell'operatore Spool](../relational-databases/media/spool-32x.gif "Icona dell'operatore Spool")|**Eager Spool**|L'operatore **Eager Spool** elabora l'intero input e archivia ogni riga in un oggetto temporaneo nascosto archiviato a sua volta nel database **tempdb** . Se l'operatore viene ripristinato, ad esempio tramite un operatore **Nested Loops** , ma non è necessario eseguire nuovamente l'associazione, l'analisi dell'input non viene ripetuta e vengono invece usati i dati di spooling. Se è necessario ripetere l'associazione, i dati di spooling vengono eliminati e l'oggetto di spooling viene ricompilato tramite una nuova analisi dell'input riassociato. L'operatore **Eager Spool** compila il proprio file di spooling nel modo seguente. Quando l'operatore principale dello spooling richiede la prima riga, l'operatore di spooling utilizza tutte le righe dal proprio operatore di input e le archivia nello spooling. **Eager Spool** è un operatore logico.|  
|![Icona dell'operatore Fetch Query per il cursore](../relational-databases/media/fetch-query-32x.gif "Icona dell'operatore Fetch Query per il cursore")|**Fetch Query**|L'operatore **Fetch Query** recupera le righe quando viene eseguita un'operazione di recupero in un cursore.|  
|![Icona dell'operatore Filter (motore di database)](../relational-databases/media/filter-32x.gif "Icona dell'operatore Filter (motore di database)")|**Filter**|L'operatore **Filter** esegue l'analisi dell'input restituendo soltanto le righe che soddisfano l'espressione di filtro (predicato) indicata nella colonna **Argument** .|  
|Nessuno|**Flow Distinct**|L'operatore logico **Flow Distinct** esegue l'analisi dell'input e rimuove i valori duplicati. Mentre l'operatore **Distinct** elabora l'intero input prima di produrre un risultato, l'operatore **FlowDistinct** restituisce ogni riga come viene ottenuta dall'input, ad eccezione delle righe duplicate che vengono eliminate.|  
|Nessuno|**Full Outer Join**|L'operatore logico **Full Outer Join** restituisce ogni riga che soddisfa il predicato di join del primo input (superiore) con ogni riga del secondo input (inferiore). L'operatore restituisce inoltre:<br /><br /> - Righe del primo input senza corrispondenze nel secondo input.<br /><br /> - Righe del secondo input senza corrispondenze nel primo input.<br /><br /> L'input che non include valori corrispondenti viene restituito come valore Null. **Full Outer Join** è un operatore logico.|  
|![Icona dell'operatore di parallelismo Gather Streams](../relational-databases/media/parallelism-32x.gif "Icona dell'operatore di parallelismo Gather Streams")|**Gather Streams**|L'operatore logico **Gather Streams** viene utilizzato esclusivamente in piani di query paralleli. Tale operatore ****  elabora vari flussi di input e quindi produce un unico flusso di output di record derivati dalla combinazione dei flussi di input. Il contenuto e il formato del record non vengono modificati. Se l'operatore prevede l'ordinamento, è necessario che tutti i flussi di input siano ordinati. Se l'output è ordinato, la colonna **Argument** contiene un predicato ORDER BY:() e i nomi delle colonne ordinate. **Gather Streams** è un operatore logico.|  
|![Icona dell'operatore Hash Match](../relational-databases/media/hash-match-32x.gif "Icona dell'operatore Hash Match")|**Hash Match**|L'operatore **Hash Match** compila una tabella hash calcolando un valore hash per ogni riga dall'input di compilazione. Nella colonna **Argument** appare un predicato HASH:() unitamente all'elenco delle colonne usate per la creazione del valore hash. Per ogni riga probe, quando applicabile, viene calcolato un valore hash (tramite la stessa funzione di hashing) e quindi vengono cercate corrispondenze nella tabella hash. Se è presente un predicato residuo, identificato da RESIDUAL:() nella colonna **Argument** , per considerare le righe come corrispondenti è necessario che sia soddisfatto anche tale predicato. Il funzionamento dipende dell'operazione logica eseguita:<br /><br /> - Per tutti i join, usare il primo input (superiore) per la compilazione della tabella hash e il secondo input (inferiore) per l'esecuzione del probe nella tabella hash. L'output delle corrispondenze (o delle mancate corrispondenze) viene eseguito in base a quanto previsto dal tipo di join. Se più join utilizzano la stessa colonna di join, le operazioni sono raggruppate in un gruppo di hash.<br /><br /> - Per gli operatori Distinct o Aggregate, usare l'input per la compilazione della tabella hash (con rimozione dei duplicati e calcolo di eventuali espressioni di aggregazione). Quando viene creata la tabella hash, vengono eseguiti l'analisi della tabella e il successivo output di tutte le voci.<br /><br /> Per l'operatore Union, usare il primo input per la compilazione della tabella hash (con rimozione dei duplicati). Il secondo input (che non deve includere duplicati) viene utilizzato per l'esecuzione del probe della tabella hash, seguita dalla restituzione di tutte le righe senza corrispondenze, dall'analisi della tabella hash e infine dalla restituzione di tutte le voci.<br /><br /> **Hash Match** è un operatore fisico.|  
|![Icona dell'elemento di linguaggio If](../relational-databases/media/if-32x.gif "Icona dell'elemento di linguaggio If")|**Se in**|L'operatore **If** esegue un'elaborazione condizionale basata su un'espressione. **If** è un elemento di linguaggio.|  
|Nessuno|**Inner join**|L'operatore logico **Inner Join** restituisce ogni riga che soddisfa il join del primo input (superiore) con il secondo input (inferiore).|  
|![Icona dell'operatore Insert (motore di database)](../relational-databases/media/insert-32x.gif "Icona dell'operatore Insert (motore di database)")|**Insert**|L'operatore **Insert** inserisce ogni riga del proprio input nell'oggetto specificato nella colonna **Argument** . L'operatore fisico è l'operatore **Table Insert**, **Index Insert**o **Clustered Index Insert** .|  
|![Icona dell'operatore Inserted Scan](../relational-databases/media/inserted-scan-32x.gif "Icona dell'operatore Inserted Scan")|**Inserted Scan**|L'operatore **Inserted Scan** esegue l'analisi della tabella **inserted** . **Inserted Scan** è un operatore logico e fisico.|  
|![Icona dell'elemento di linguaggio Intrinsic](../relational-databases/media/intrinsic-32x.gif "Icona dell'elemento di linguaggio Intrinsic")|**Intrinsic**|L'operatore **Intrinsic** richiama una funzione [!INCLUDE[tsql](../includes/tsql-md.md)] interna. **Intrinsic** è un elemento di linguaggio.|  
|![Icona generica dell'operatore Iterator](../relational-databases/media/iterator-catch-all.gif "Icona generica dell'operatore Iterator")|**Iterator**|L'icona generica per **Iterator** viene visualizzata quando la logica che produce Showplan grafici non è in grado di individuare un'icona appropriata per l'iteratore. L'icona generica non indica necessariamente una condizione di errore. Sono disponibili tre icone generiche: blu (per gli iteratori), arancione (per i cursori) e verde (per i costrutti del linguaggio [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Icona dell'operatore Bookmark Lookup](../relational-databases/media/bookmark-lookup-32x.gif "Icona dell'operatore Bookmark Lookup")|**Key Lookup**|L'operatore **Key Lookup** implementa la funzionalità di ricerca tramite segnalibro per le tabelle con un indice cluster. La colonna **Argument** contiene il nome dell'indice cluster e la chiave di clustering utilizzata per la ricerca della riga nell'indice cluster. L'operatore**Key Lookup** è sempre utilizzato in combinazione con un operatore **Nested Loops** . Se nella colonna **Argument** viene visualizzata la clausola WITH PREFETCH, Query Processor considera ottimale l'uso della prelettura asincrona (read-ahead) per la ricerca di segnalibri nell'indice cluster.<br /><br /> L'utilizzo di un operatore **Key Lookup** in un piano di query indica che l'ottimizzazione delle prestazioni potrebbe consentire di ottenere risultati migliori per la query. Le prestazioni della query, ad esempio, potrebbero essere migliorate con l'aggiunta di un indice di copertura.|  
|![Icona dell'operatore Keyset per il cursore](../relational-databases/media/keyset-32x.gif "Icona dell'operatore Keyset per il cursore")|**Keyset**|L'operatore **Keyset** utilizza un cursore in grado di riconoscere gli aggiornamenti ma non gli inserimenti eseguiti da altri.|  
|![Icona generica per Language Element](../relational-databases/media/language-construct-catch-all.gif "Icona generica per Language Element")|**Elemento Language**|L'icona generica per **Language Element** viene visualizzata quando la logica che produce Showplan grafici non è in grado di individuare un'icona appropriata per l'iteratore. L'icona generica non indica necessariamente una condizione di errore. Sono disponibili tre icone generiche: blu (per gli iteratori), arancione (per i cursori) e verde (per i costrutti del linguaggio [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Icona dell'operatore Spool](../relational-databases/media/spool-32x.gif "Icona dell'operatore Spool")|**Lazy Spool**|L'operatore logico **Lazy Spool** archivia ogni riga dell'input in un oggetto temporaneo nascosto memorizzato nel database **tempdb** . Se l'operatore viene ripristinato, ad esempio tramite un operatore **Nested Loops** , ma non è necessario eseguire nuovamente l'associazione, l'analisi dell'input non viene ripetuta e vengono invece usati i dati di spooling. Se è necessario ripetere l'associazione, i dati di spooling vengono eliminati e l'oggetto di spooling viene ricompilato tramite una nuova analisi dell'input riassociato. L'operatore **Lazy Spool** compila il file di spooling con un'elaborazione lenta: ogni volta che l'operatore padre dello spooling richiede una riga, anziché elaborare contemporaneamente tutte le righe, l'operatore di spooling ottiene una riga dal relativo operatore di input e la archivia nel file di spooling. Lazy Spool è un operatore logico.|  
|Nessuno|**Left Anti Semi Join**|L'operatore **Left Anti Semi Join** restituisce ogni riga del primo input (superiore) alla quale non corrisponde nessuna riga del secondo input (inferiore). Se nella colonna **Argument** non è presente un predicato di join, ogni riga viene interpretata come riga corrispondente. **Left Anti Semi Join** è un operatore logico.|  
|Nessuno|**Left Outer Join**|L'operatore **Left Outer Join** restituisce ogni riga che soddisfa il join del primo input (superiore) con il secondo input (inferiore). L'operatore restituisce inoltre ogni riga del primo input alla quale non corrisponde una riga nel secondo input. Le righe senza corrispondenza nel secondo input vengono restituite come valori Null. Se nella colonna **Argument** non è presente un predicato di join, ogni riga viene interpretata come riga corrispondente. **Left Outer Join** è un operatore logico.|  
|Nessuno|**Left Semi Join**|L'operatore **Left Semi Join** restituisce ogni riga del primo input (superiore) alla quale corrisponde una riga del secondo input (inferiore). Se nella colonna **Argument** non è presente un predicato di join, ogni riga viene interpretata come riga corrispondente. **Left Semi Join** è un operatore logico.|  
|![Icona dell'operatore Log Row Scan](../relational-databases/media/log-row-scan-32x.gif "Icona dell'operatore Log Row Scan")|**Log Row Scan**|L'operatore **Log Row Scan** esegue l'analisi del log delle transazioni. **Log Row Scan** è un operatore logico e fisico.|  
|![Icona dell'operatore Merge Interval](../relational-databases/media/merge-interval-32x.gif "Icona dell'operatore Merge Interval")|**Merge Interval**|L'operatore **Merge Interval** unisce più intervalli (potenzialmente sovrapposti) e restituisce intervalli minimi non sovrapposti, usati per la ricerca di voci di indice. Questo operatore appare in genere sopra uno o più operatori **Compute Scalar** negli operatori **Constant Scan** . Tali operatori creano gli intervalli (rappresentati da colonne di una riga) uniti dall'operatore. **Merge Interval** è un operatore logico e fisico.|  
|![Icona dell'operatore Merge Join](../relational-databases/media/merge-join-32x.gif "Icona dell'operatore Merge Join")|**Merge Join**|L'operatore **Merge Join** esegue le operazioni di inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join e union logical.<br /><br /> Nella colonna **Argument** l'operatore **Merge Join** include un predicato MERGE:() se è in esecuzione un join di tipo uno-a-molti, oppure un predicato MANY-TO-MANY MERGE:() se è in esecuzione un join di tipo molti-a-molti. La colonna **Argument** include anche un elenco separato da virgole delle colonne usate per l'esecuzione dell'operazione. L'operatore **Merge Join** richiede due input ordinati in base alle rispettive colonne, eventualmente tramite l'inserimento di operazioni di ordinamento esplicite nel piano di query. Merge Join è particolarmente efficace se non è richiesto l'ordinamento esplicito, ad esempio se nel database è presente un indice ad albero B adeguato o se il tipo di ordinamento è utilizzabile per più operazioni, quali merge join e raggruppamenti con rollup. **Merge Join** è un operatore fisico.|  
|![Icona dell'operatore Nested Loops](../relational-databases/media/nested-loops-32x.gif "Icona dell'operatore Nested Loops")|**Nested Loops**|L'operatore **Nested Loops** esegue le operazioni logiche di inner join, left outer join, left semi join e left anti semi join. I join a cicli annidati eseguono una ricerca nella tabella interna per ogni riga della tabella esterna, usando generalmente un indice. Query processor determina, in base ai costi previsti, se ordinare l'input esterno per migliorare le ricerche basate sull'indice rispetto all'input interno. Vengono restituite le righe conformi al predicato (facoltativo) nella colonna **Argument** a seconda dell'operazione logica eseguita. **Nested Loops** è un operatore fisico.|  
|![Icona dell'operatore Nonclustered Index Delete](../relational-databases/media/nonclust-index-delete-32x.gif "Icona dell'operatore Nonclustered Index Delete")|**Nonclustered Index Delete**|L'operatore **Nonclustered Index Delete** elimina le righe di input dall'indice non cluster specificato nella colonna **Argument** . **Nonclustered Index Delete** è un operatore fisico.|  
|![Icona dell'operatore Index Insert per indice non cluster](../relational-databases/media/nonclust-index-insert-32x.gif "Icona dell'operatore Index Insert per indice non cluster")|**Index Insert**|L'operatore **Index Insert** inserisce righe del proprio input nell'indice non cluster specificato nella colonna **Argument** . La colonna **Argument** include anche un predicato SET:(), che indica il valore su cui viene impostata ogni colonna. **Index Insert** è un operatore fisico.|  
|![Icona dell'operatore Index Scan per indice non cluster](../relational-databases/media/nonclustered-index-scan-32x.gif "Icona dell'operatore Index Scan per indice non cluster")|**Index Scan**|L'operatore **Index Scan** recupera tutte le righe dall'indice non cluster specificato nella colonna **Argument** . Se nella colonna **Argument** è presente un predicato WHERE:() facoltativo, vengono restituite solo le righe conformi al predicato. **Index Scan** è un operatore logico e fisico.|  
|![Icona dell'operatore Index Seek per indice non cluster](../relational-databases/media/index-seek-32x.gif "Icona dell'operatore Index Seek per indice non cluster")|**Index Seek**|L'operatore **Index Seek** utilizza le funzionalità di ricerca degli indici per recuperare righe da un indice non cluster. La colonna dell'argomento ****  include il nome dell'indice non cluster utilizzato. La colonna include inoltre il predicato SEEK:(). Il motore di archiviazione utilizza l'indice per elaborare soltanto le righe conformi al predicato SEEK:() Facoltativamente esso può includere un predicato WHERE:(), che verrà valutato dal motore di archiviazione rispetto a tutte le righe conformi al predicato SEEK:() (non utilizza gli indici per tale operazione). Se la colonna dell'argomento ****  include la clausola ORDERED, Query Processor ha determinato che le righe devono essere restituite nello stesso ordine utilizzato dall'indice non cluster. In assenza della clausola ORDERED, il motore di archiviazione esegue una ricerca nell'indice utilizzando il metodo ottimale (con output non necessariamente ordinato). Il mantenimento dell'ordinamento dell'output può dare come risultato un livello di efficienza minore rispetto alla restituzione di output non ordinato. **Index Seek** è un operatore logico e fisico.|  
|![Icona dell'operatore Index Spool per indice non cluster](../relational-databases/media/index-spool-32x.gif "Icona dell'operatore Index Spool per indice non cluster")|**Index Spool**|L'operatore fisico **Index Spool** contiene un predicato SEEK:() nella colonna **Argument** . L'operatore **Index Spool** esegue l'analisi delle proprie righe di input e inserisce una copia di ogni riga in un file di spooling nascosto (archiviato nel database **tempdb** e con durata equivalente a quella della query), quindi compila un indice non cluster sulle righe. Ciò consente di utilizzare la funzionalità di ricerca degli indici per restituire solo le righe che soddisfano il predicato SEEK:(). Se l'operatore viene ripristinato, ad esempio tramite un operatore **Nested Loops** , ma non è necessario eseguire nuovamente l'associazione, l'analisi dell'input non viene ripetuta e vengono invece usati i dati di spooling.|  
|![Icona dell'operatore Nonclustered Index Update](../relational-databases/media/nonclust-index-update-32x.gif "Icona dell'operatore Nonclustered Index Update")|**Nonclustered Index Update**|L'operatore fisico **Nonclustered Index Update** aggiorna righe del proprio input nell'indice non cluster specificato nella colonna **Argomento** . Se è stato specificato un predicato SET:(), ogni colonna aggiornata viene impostata su tale valore. **Nonclustered Index Update** è un operatore fisico.|  
|![Icona dell'operatore Online Index Insert](../relational-databases/media/online-index-32x.gif "Icona dell'operatore Online Index Insert")|**Online Index Insert**|L'operatore fisico **Online Index Insert** indica che la creazione, la modifica o l'eliminazione di un indice viene eseguita online, ovvero che i dati della tabella sottostante rimangono disponibili agli utenti durante l'operazione sull'indice.|  
|Nessuno|**Parallelism**|L'operatore **Parallelism** esegue operazioni logiche di tipo distribute streams, gather streams e repartition streams. Le colonne **Argument** possono contenere un predicato PARTITION COLUMNS:() con un elenco delimitato da virgole contenente le colonne partizionate. Le colonne **Argument** possono includere inoltre un predicato ORDER BY:(), che elenca le colonne di cui deve essere mantenuto l'ordinamento durante il partizionamento. **Parallelism** è un operatore fisico.<br /><br /> <br /><br /> Nota: se una query è stata compilata come parallela, ma in fase di esecuzione viene eseguita come seriale, l'output Showplan generato da SET STATISTICS XML o dall'opzione **Includi piano di esecuzione effettivo** in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] non includerà l'elemento **RunTimeInformation** per l'operatore **Parallelism** . Nell'output di SET STATISTICS PROFILE i conteggi delle righe effettivi e il numero effettivo delle esecuzioni indicheranno zero per l'operatore **Parallelism** . Quando una delle due condizioni si verifica, significa che l'operatore **Parallelism** è stato usato solo durante la compilazione delle query e non nel piano di query di runtime. Si noti che talvolta i piani di query parallele vengono eseguiti in serie se il carico simultaneo del server è elevato.|  
|![Icona dell'operatore Parameter Table Scan](../relational-databases/media/parameter-table-scan-32x.gif "Icona dell'operatore Parameter Table Scan")|**Parameter Table Scan**|L'operatore **Parameter Table Scan** esegue l'analisi di una tabella che funge da parametro nella query corrente. In genere questa funzionalità è utilizzata per le query INSERT all'interno di una stored procedure. **Parameter Table Scan** è un operatore logico e fisico.|  
|Nessuno|**Partial Aggregate**|L'operatore**Partial Aggregate** è utilizzato nei piani paralleli. Applica una funzione di aggregazione al maggior numero possibile di righe di input in modo che la scrittura su disco (operazione nota come "spill") non sia necessaria. **Hash Match** è l'unico operatore fisico (iteratore) che implementa l'aggregazione delle partizioni. **Partial Aggregate** è un operatore logico.|  
|![Icona dell'operatore Population Query per il cursore](../relational-databases/media/poulation-query-32x.gif "Icona dell'operatore Population Query per il cursore")|**Population Query**|All'apertura di un cursore, l'operatore **Population Query** esegue il popolamento della relativa tabella di lavoro.|  
|![Icona dell'operatore Refresh Query per il cursore](../relational-databases/media/refresh-query-32x.gif "Icona dell'operatore Refresh Query per il cursore")|**Refresh Query**|L'operatore **Refresh Query** recupera i dati correnti per le righe nel buffer di recupero.|  
|![Icona dell'operatore Remote Delete](../relational-databases/media/remote-delete-32x.gif "Icona dell'operatore Remote Delete")|**Remote Delete**|L'operatore **Remote Delete** elimina le righe di input da un oggetto remoto. **Remote Delete** è un operatore logico e fisico.|  
|![Operatore Showplan Remote Index Scan](../relational-databases/media/remote-index-scan-32x.gif "Operatore Showplan Remote Index Scan")|**Remote Index Scan**|L'operatore **Remote Index Scan** analizza l'indice remoto specificato nella colonna Argument. **Remote Insert Scan** è un operatore logico e fisico.|  
|![Operatore Showplan Remote Index Seek](../relational-databases/media/remote-index-seek-32x.gif "Operatore Showplan Remote Index Seek")|**Remote Index Seek**|L'operatore **Remote Index Seek** utilizza le capacità di ricerca di un oggetto Index remoto per il recupero di righe. La colonna **Argument** include il nome dell'indice remoto usato e il predicato SEEK:(). **Remote Insert Seek** è un operatore logico fisico.|  
|![Icona dell'operatore Remote Insert](../relational-databases/media/remote-insert-32x.gif "Icona dell'operatore Remote Insert")|**Remote Insert**|L'operatore **Remote Insert** inserisce le righe di input in un oggetto remoto. **Remote Insert** è un operatore logico e fisico.|  
|![Icona dell'operatore Remote Query](../relational-databases/media/remote-query-32x.gif "Icona dell'operatore Remote Query")|**Remote Query**|L'operatore **Remote Query** invia una query a un'origine remota. Il testo della query inviata al server remoto viene visualizzato nella colonna **Argument** . **Remote Query** è un operatore logico e fisico.|  
|![Icona dell'operatore Remote Scan](../relational-databases/media/remote-scan-32x.gif "Icona dell'operatore Remote Scan")|**Remote Scan**|L'operatore **Remote Scan** esegue l'analisi di un oggetto remoto. Il nome dell'oggetto remoto appare nella colonna **Argomento** . **Remote Scan** è un operatore logico e fisico.|  
|![Icona dell'operatore Remote Update](../relational-databases/media/remote-update-32x.gif "Icona dell'operatore Remote Update")|**Remote Update**|L'operatore **Remote Update** aggiorna le righe di input in un oggetto remoto. **Remote Update** è un operatore logico e fisico.|  
|![Icona dell'operatore di parallelismo Repartition Streams](../relational-databases/media/parallelism-repartition-stream.gif "Icona dell'operatore di parallelismo Repartition Streams")|**Repartition Streams**|L'operatore **Repartition Streams** elabora più flussi e restituisce più flussi di record. Il contenuto e il formato del record non vengono modificati. Se Query Optimizer utilizza un filtro bitmap, il numero di righe nel flusso di output è ridotto. Ogni record di un flusso di input viene inserito in un flusso di output. Se l'operatore prevede il rispetto dell'ordine, è necessario che tutti i flussi di input risultino ordinati e vengano uniti in vari flussi di output ordinati. Se l'output è partizionato, la colonna **Argument** contiene un predicato PARTITION COLUMNS:() e le colonne di partizionamento, mentre se l'output è ordinato, la colonna **Argument** contiene un predicato ORDER BY:() e le colonne da ordinare. **Repartition Streams** è un operatore logico. L'operatore viene utilizzato solo nei piani di query parallele.|  
|![Icona dell'elemento di linguaggio Result](../relational-databases/media/result-32x.gif "Icona dell'elemento di linguaggio Result")|**Result**|L'operatore **Result** corrisponde ai dati restituiti alla fine di un piano di query ed è in genere l'elemento radice di uno Showplan. **Result** è un elemento di linguaggio.|  
|![Icona dell'operatore RID Lookup](../relational-databases/media/rid-nonclust-locate-32x.gif "Icona dell'operatore RID Lookup")|**RID Lookup**|**RID Lookup** implementa la funzionalità di ricerca tramite segnalibro in un heap mediante un identificatore di riga (RID) che viene passato all'operatore. La colonna **Argument** contiene l'etichetta del segnalibro utilizzata per la ricerca della riga nella tabella e il nome della tabella in cui viene cercata la riga. **RID Lookup** è sempre utilizzato in combinazione con un operatore NESTED LOOP JOIN. **RID Lookup** è un operatore fisico. Per ulteriori informazioni sulle ricerche tramite segnalibro, vedere "[Bookmark Lookup](http://go.microsoft.com/fwlink/?LinkId=132568)" nel blog su SQL Server in MSDN.|  
|Nessuno|**Right Anti Semi Join**|L'operatore **Right Anti Semi Join** restituisce ogni riga del secondo input (inferiore) alla quale non corrisponde alcuna riga nel primo input (superiore). Una riga corrispondente è una riga conforme al predicato presente nella colonna **Argument** . Se non è presente alcun predicato, ogni riga viene interpretata come riga corrispondente. **Right Anti Semi Join** è un operatore logico.|  
|Nessuno|**Right Outer Join**|L'operatore logico **Right Outer Join** restituisce ogni riga che soddisfa il join del secondo input (inferiore) con ogni riga corrispondente del primo input (superiore). L'operatore restituisce inoltre ogni riga del secondo input alla quale non corrisponde una riga nel primo input, con join a valori NULL. Se nella colonna **Argument** non è presente un predicato di join, ogni riga viene interpretata come riga corrispondente. **Right Outer Join** è un operatore logico.|  
|Nessuno|**Right Semi Join**|L'operatore **Right Semi Join** restituisce ogni riga del secondo input (inferiore) alla quale corrisponde una riga del primo input (superiore). Se nella colonna **Argument** non è presente un predicato di join, ogni riga viene interpretata come riga corrispondente. **Right Semi Join** è un operatore logico.|  
|![Icona dell'operatore Row Count Spool](../relational-databases/media/remote-count-spool-32x.gif "Icona dell'operatore Row Count Spool")|**Row Count Spool**|L'operatore **Row Count Spool** esegue l'analisi dell'input calcolando e restituendo il numero di righe presenti senza alcun dato. Questo operatore viene utilizzato quando è importante verificare l'esistenza delle righe anziché i dati contenuti nelle righe. Ad esempio, se un operatore **Nested Loops** esegue un'operazione di left semi join e il predicato di join è relativo all'input interno, è possibile che nella parte superiore dell'input interno dell'operatore **Nested Loops** venga inserito uno spooler di conteggio righe. In tal modo l'operatore **Nested Loops** può registrare il numero di righe di output indicate dallo spooler di conteggio righe (i dati dell'input interno non sono necessari) e determinare se restituire la riga esterna. **Row Count Spool** è un operatore fisico.|  
|![Icona dell'operatore Segment](../relational-databases/media/segment-32x.gif "Icona dell'operatore Segment")|**Segment**|**Segment** è un operatore fisico e logico L'operatore divide il set di input in segmenti in base al valore di una o più colonne Tali colonne vengono visualizzate come argomenti nell'operatore **Segment** e quindi restituisce un segmento per volta.|  
|Nessuno|**Segment Repartition**|In un piano di query parallele sono presenti talvolta regioni concettuali di iteratori. È possibile eseguire tutti gli iteratori all'interno di tale regione mediante thread paralleli. Le regioni devono invece essere eseguite in modalità seriale. Alcuni iteratori **Parallelism** all'interno di una singola regione sono denominati **Branch Repartition**. L'operatore **Parallelism** al confine tra due regioni di questo tipo viene denominato **Segment Repartition**. **Branch Repartition** e **Segment Repartition** sono operatori logici.|  
|![Icona dell'operatore Sequence](../relational-databases/media/sequence-32x.gif "Icona dell'operatore Sequence")|**Sequence**|L'operatore **Sequence** indirizza i piani di aggiornamento estesi. A livello funzionale l'operatore esegue ogni input in sequenza (dall'alto verso il basso). Ogni input è in genere un aggiornamento di un oggetto diverso. L'operatore restituisce soltanto le righe derivanti dall'ultimo input (inferiore). **Sequence** è un operatore logico e fisico.|  
|![Icona dell'operatore Sequence Project](../relational-databases/media/sequence-project-32x.gif "Icona dell'operatore Sequence Project")|**Sequence Project**|L'operatore **Sequence Project** consente di aggiungere colonne per eseguire calcoli in un set ordinato. L'operatore divide il set di input in segmenti in base al valore di una o più colonne e quindi restituisce un segmento per volta. Tali colonne vengono visualizzate come argomenti nell'operatore **Sequence Project** . **Sequence Project** è un operatore logico e fisico.|  
|![Icona dell'operatore Snapshot per il cursore](../relational-databases/media/snapshot-32x.gif "Icona dell'operatore Snapshot per il cursore")|**Snapshot**|L'operatore **Snapshot** crea un cursore che non consente di visualizzare le modifiche apportate da altri utenti.|  
|![Icona dell'operatore Sort](../relational-databases/media/sort-32x.gif "Icona dell'operatore Sort")|**Sort**|L'operatore **Sort** ordina tutte le righe in ingresso. La colonna **Argument** contiene un predicato DISTINCT ORDER BY:() se tramite l'operazione vengono eliminati i duplicati oppure un predicato ORDER BY:() con un elenco delimitato da virgole in cui sono incluse le colonne ordinate. Alle colonne viene assegnato il prefisso ASC se sono ordinate in ordine crescente o il prefisso DESC se sono ordinate in ordine decrescente. **Sort** è un operatore logico e fisico.|  
|![Icona dell'operatore Split](../relational-databases/media/split-32x.gif "Icona dell'operatore Split")|**Split**|L'operatore **Split** consente di ottimizzare l'elaborazione degli aggiornamenti. Ogni operazione di aggiornamento viene suddivisa in un'operazione di eliminazione e un'operazione di inserimento. **Split** è un operatore logico e fisico.|  
|![Icona dell'operatore Spool](../relational-databases/media/spool-32x.gif "Icona dell'operatore Spool")|**Spool**|L'operatore **Spool** salva risultati di query intermedi nel database **tempdb** .|  
|![Icona dell'operatore Stream Aggregate](../relational-databases/media/stream-aggregate-32x.gif "Icona dell'operatore Stream Aggregate")|**Stream Aggregate**|L'operatore **Stream Aggregate** raggruppa le righe in base a una o più colonne e quindi calcola una o più espressioni di aggregazione restituite dalla query. L'output di questo operatore può essere utilizzato come riferimento da operatori successivi nella query, può essere restituito al client o può essere oggetto di entrambe le operazioni. Per l'operatore **Stream Aggregate** è necessario che l'input sia ordinato in base alle colonne all'interno del relativo gruppo. In Query Optimizer verrà utilizzato un operatore **Sort** prima di questo se i dati non sono già stati ordinati tramite un operatore **Sort** precedente o tramite una ricerca o un'analisi di un indice ordinato. Nell'istruzione SHOWPLAN_ALL o nel piano di esecuzione grafico in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]le colonne incluse nel predicato GROUP BY sono elencate nella colonna **Argument** , mentre le espressioni di aggregazione sono elencate nella colonna **Defined Values** . **Stream Aggregate** è un operatore fisico.|  
|![Icona dell'operatore Switch](../relational-databases/media/switch-32x.gif "Icona dell'operatore Switch")|**Opzione**|**Opzione** è un tipo speciale di iteratore di concatenazione con  *n*  input. A ogni operatore **Switch** è associata un'espressione. A seconda del valore restituito dell'espressione (compreso tra 0 e  *n* -1), **commutatore** copia il flusso di input appropriato nel flusso di output. Tra i possibili utilizzi dell'operatore **Switch** è inclusa l'implementazione di query che richiedono cursori fast forward con operatori specifici, ad esempio l'operatore **TOP** . **Switch** è un operatore logico e fisico.|  
|![Icona dell'operatore Table Delete](../relational-databases/media/table-delete-32x.gif "Icona dell'operatore Table Delete")|**Table Delete**|L'operatore **Table Delete** fisico elimina righe dalla tabella specificata nella colonna **Argument** del piano di esecuzione della query.|  
|![Icona dell'operatore Table Insert](../relational-databases/media/table-insert-32x.gif "Icona dell'operatore Table Insert")|**Table Insert**|L'operatore **Table Insert** inserisce righe dal proprio input nella tabella specificata nella colonna **Argument** del piano di esecuzione della query. La colonna **Argument** include anche un predicato SET:(), che indica il valore su cui viene impostata ogni colonna. Se in **Table Insert** non sono disponibili figli per i valori Insert, la riga inserita verrà recuperata dall'operatore Insert stesso. **Table Insert** è un operatore fisico.|  
|![Icona dell'operatore Table Merge](../relational-databases/media/table-merge-32x.gif "Icona dell'operatore Table Merge")|**Table Merge**|L'operatore **Table Merge** applica un flusso di dati di unione a un heap. L'operatore elimina, aggiorna o inserisce righe nella tabella specificata nella colonna ****  dell'argomento dell'operatore. L'operazione effettiva eseguita dipende dal valore di runtime della colonna **ACTION** specificato nella colonna **Argument** dell'operatore. **Table Merge** è un operatore fisico.|  
|![Icona dell'operatore Table Scan](../relational-databases/media/table-scan-32x.gif "Icona dell'operatore Table Scan")|**Table Scan**|L'operatore **Table Scan** recupera tutte le righe dalla tabella specificata nella colonna **Argument** del piano di esecuzione della query. Se nella colonna **Argument** è presente un predicato WHERE:(), vengono restituite solo le righe conformi al predicato. **Table Scan** è un operatore logico e fisico.|  
|![Icona dell'operatore Table Spool](../relational-databases/media/table-spool-32x.gif "Icona dell'operatore Table Spool")|**Table Spool**|L'operatore **Table Spool** esegue l'analisi dell'input e inserisce una copia di ogni riga in una tabella di spooling nascosta archiviata nel database [tempdb](../relational-databases/databases/tempdb-database.md) e con durata limitata alla durata della query. Se l'operatore viene ripristinato, ad esempio tramite un operatore **Nested Loops** , ma non è necessario eseguire nuovamente l'associazione, l'analisi dell'input non viene ripetuta e vengono invece usati i dati di spooling. **Table Spool** è un operatore fisico.|  
|![Icona dell'operatore Table Update](../relational-databases/media/table-update-32x.gif "Icona dell'operatore Table Update")|**Table Update**|L'operatore fisico **Table Update** aggiorna le righe di input nella tabella specificata nella colonna **Argument** del piano di esecuzione della query. Il predicato SET:() determina il valore di ogni colonna aggiornata. Un riferimento a tali valori può essere presente nella clausola SET o in altri punti dell'operatore o nella query.|  
|![Icona dell'operatore Table-valued Function](../relational-databases/media/table-valued-function-32x.gif "Icona dell'operatore Table-valued Function")|**Table-valued Function**|L'operatore **Table-valued Function** valuta una funzione con valori di tabella ( [!INCLUDE[tsql](../includes/tsql-md.md)] o CLR) e archivia le righe risultanti nel database [tempdb](../relational-databases/databases/tempdb-database.md) . Quando gli iteratori del padre richiedono le righe, **Table-valued Function** restituisce le righe da **tempdb**.<br /><br /> Le query con chiamate a funzioni con valori di tabella generano piani di query con l'iteratore **Table-valued Function** . **Table-valued Function** può essere valutato con valori di parametri diversi:<br /><br /> -<br />                    **Table-valued Function XML Reader** specifica come parametro di input un BLOB XML e produce un set di righe che rappresentano i nodi XML nell'ordine di un documento XML. Altri parametri di input possono limitare i nodi XML restituiti a un subset di un documento XML.<br /><br /> -**Table Valued Function XML Reader con filtro XPath** è un tipo speciale di **XML Reader Table-valued Function** che limita l'output ai nodi XML che soddisfano un'espressione XPath.<br /><br /> **Table-valued Function** è un operatore logico e fisico.|  
|![Icona dell'operatore Top](../relational-databases/media/top-32x.gif "Icona dell'operatore Top")|**Top**|L'operatore **Top** esegue l'analisi dell'input e restituisce solo il primo numero o valore percentuale di righe specificato, eventualmente in base a un ordinamento. La colonna **Argument** può includere l'elenco delle colonne in cui si verifica la presenza di collegamenti. Nei piani di aggiornamento l'operatore **Top** consente di applicare limiti di conteggio righe. **Top** è un operatore logico e fisico. **Top** è un operatore logico e fisico.|  
|Nessuno|**Top N Sort**|**Top N Sort** è simile all'iteratore **Sort** , ma richiede solo le prime *N* righe non l'intero set di risultati. Per valori bassi di *N*, il motore di esecuzione delle query di [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] prova a eseguire l'intera operazione di ordinamento in memoria. Nel caso di valori elevati di *N*, il motore di esecuzione delle query ricorre al metodo di ordinamento più generico in cui *N* non corrisponde a un parametro.|  
|![Icona di operatore esteso (UDX)](../relational-databases/media/udx-32x.gif "Icona di operatore esteso (UDX)")|**UDX**|Gli operatori estesi (UDX) implementano una delle varie operazioni XQuery e XPath in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Tutti gli operatori UDX sono logici e fisici.<br /><br /> L'operatore esteso (UDX) **FOR XML** è usato per serializzare gli input del set di righe relazionale nella rappresentazione XML in un'unica colonna BLOB in un'unica riga di output. È un operatore di aggregazione XML sensibile all'ordinamento.<br /><br /> L'operatore esteso (UDX) **XML SERIALIZER** è un operatore di aggregazione XML sensibile all'ordinamento. Inserisce righe che rappresentano nodi XML o valori scalari XQuery nell'ordine dei documenti XML e genera un BLOB XML serializzato in un'unica colonna XML in una singola colonna di output.<br /><br /> L'operatore esteso (UDX) **XML FRAGMENT SERIALIZER** è un particolare tipo di **XML SERIALIZER** usato per l'elaborazione delle righe di input che rappresentano frammenti XML da inserire nell'estensione INSERT di XQuery per la modifica di dati.<br /><br /> L'operatore esteso (UDX) **XQUERY STRING** valuta il valore stringa XQuery delle righe di input che rappresentano i nodi XML. È un operatore di aggregazione di stringa sensibile all'ordinamento. Restituisce come output una riga con colonne che rappresentano il valore scalare XQuery che include il valore stringa dell'input.<br /><br /> L'operatore esteso (UDX) **XQUERY LIST DECOMPOSER** è un operatore di scomposizione di elenco XQuery. Per ogni riga di input che rappresenta un nodo XML, genera una o più righe, ognuna delle quali rappresenta un valore scalare XQuery che include un valore di voce di elenco se l'input è di tipo elenco XSD.<br /><br /> L'operatore esteso (UDX) **XQUERY DATA** valuta la funzione XQuery fn:data() rispetto all'input che rappresenta i nodi XML. È un operatore di aggregazione di stringa sensibile all'ordinamento. Restituisce come output una riga con colonne che rappresentano il valore scalare XQuery che include il risultato di **fn:data()**.<br /><br /> L'operatore esteso **XQUERY CONTAINS** valuta la funzione XQuery fn:contains() rispetto all'input che rappresenta i nodi XML. È un operatore di aggregazione di stringa sensibile all'ordinamento. Restituisce come output una riga con colonne che rappresentano il valore scalare XQuery che include il risultato di **fn:contains()**.<br /><br /> L'operatore esteso **UPDATE XML NODE** aggiorna il nodo XML nell'estensione di modifica dei dati di sostituzione XQuery nel metodo **modify()** sul tipo XML.|  
|Nessuno|**Union**|L'operatore **Union** esegue l'analisi di più input e restituisce ogni riga sottoposta ad analisi rimuovendo i duplicati. L'operatore**Union** è un operatore logico.|  
|![Icona dell'operatore Update (motore di database)](../relational-databases/media/update-32x.gif "Icona dell'operatore Update (motore di database)")|**Update**|L'operatore **Update** aggiorna ogni riga dal proprio input nell'oggetto specificato nella colonna **Argument** del piano di esecuzione della query. **Update** è un operatore logico. L'operatore fisico è **Table Update**, **Index Update**o **Clustered Index Update**.|  
|![Icona dell'elemento di linguaggio While](../relational-databases/media/while-32x.gif "Icona dell'elemento di linguaggio While")|**While**|L'operatore **While** implementa il ciclo while di [!INCLUDE[tsql](../includes/tsql-md.md)] . **While** è un elemento di linguaggio.|  
|![Icona dell'operatore Table Spool](../relational-databases/media/table-spool-32x.gif "Icona dell'operatore Table Spool")|**Window Spool**|L'operatore **Window Spool** espande ogni riga nel set di righe che rappresenta la finestra associata. In una query la clausola OVER definisce la finestra all'interno di un set di risultati della query, quindi una funzione della finestra calcola un valore per ogni riga della finestra stessa. **Window Spool** è un operatore logico e fisico.|  
  
  


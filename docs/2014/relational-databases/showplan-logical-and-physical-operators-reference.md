---
title: Guida di riferimento a operatori Showplan logici e fisici | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.suite: ''
ms.technology:
- database-engine
ms.tgt_pltfrm: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
caps.latest.revision: 51
author: rothja
ms.author: jroth
manager: craigg
ms.openlocfilehash: 99d305034989f0fdd2f9ca65dae9cef7d0881c2c
ms.sourcegitcommit: c18fadce27f330e1d4f36549414e5c84ba2f46c2
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/02/2018
ms.locfileid: "37160632"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Guida di riferimento a operatori Showplan logici e fisici
  Gli operatori descrivono la modalità di esecuzione di una query o di un'istruzione del linguaggio di manipolazione dei dati (DML, Data Manipulation Language) in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] . In Query Optimizer gli operatori consentono di compilare un piano di query per ottenere i risultati specificati nella query o per eseguire l'operazione specificata nell'istruzione DML. Il piano di query è un albero composto da operatori fisici che è possibile visualizzare tramite le istruzioni SET SHOWPLAN, le opzioni del piano di esecuzione grafico in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]o le classi di eventi Showplan di SQL Server Profiler.  
  
 Gli operatori sono suddivisi in operatori logici e fisici.  
  
 **Operatori logici**  
 Gli operatori logici descrivono l'operazione algebrica relazionale utilizzata per elaborare un'istruzione, ovvero descrivono a livello concettuale quale operazione deve essere eseguita.  
  
 **Operatori fisici**  
 Gli operatori fisici implementano l'operazione descritta dagli operatori logici. Ogni operatore fisico è un oggetto o una routine che esegue un'operazione. Alcuni operatori fisici, ad esempio, accedono alle colonne o alle righe di una tabella, di un indice o di una vista, mentre altri eseguono operazioni diverse, ad esempio calcoli, aggregazioni, controlli di integrità dei dati o creazione di join. Gli operatori fisici possono influire sulle prestazioni.  
  
 Dopo essere stati inizializzati, gli operatori fisici raccolgono dati e quindi vengono chiusi. Un operatore fisico risponde alle tre chiamate di metodo seguenti:  
  
-   **Init()**: con la chiamata del metodo **Init()** un operatore fisico si autoinizializza e imposta le strutture di dati necessarie. Sebbene l'operatore fisico possa ricevere molte chiamate **Init()** , in genere ne riceve una sola.  
  
-   **GetNext()**: con la chiamata del metodo **GetNext()** un operatore fisico recupera la prima riga di dati oppure la successiva. L'operatore fisico può ricevere più chiamate **GetNext()** oppure nessuna.  
  
-   **Close()**: con la chiamata del metodo **Close()** un operatore fisico esegue alcune operazioni di eliminazione e viene quindi chiuso automaticamente. Un operatore fisico riceve una sola chiamata del metodo **Close()** .  
  
 Il metodo **GetNext()** restituisce una riga di dati e il numero di chiamate ricevute viene visualizzato come **ActualRows** nell'output Showplan generato usando SET STATISTICS PROFILE ON o SET STATISTICS XML ON. Per altre informazioni su queste opzioni SET, vedere [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) e [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).  
  
 I conteggi **ActualRebinds** e **ActualRewinds** visualizzati nell'output Showplan fanno riferimento al numero di chiamate al metodo **Init()**. A meno che un operatore non sia nel lato interno di un join ciclico, **ActualRebinds** è uguale a uno e **ActualRewinds** è uguale a zero. Se un operatore si trova nel lato interno di un join ciclico, la somma del numero delle associazioni e dei ripristini dovrebbe essere pari al numero delle righe elaborate nel lato esterno del join. Una riassociazione significa che uno o più parametri correlati del join sono stati modificati e che è necessario rivalutare il lato interno. Un ripristino significa che nessuno dei parametri correlati è stato modificato e che è possibile riutilizzare il set di risultati interno precedente.  
  
 **ActualRebinds** e **ActualRewinds** sono inclusi nell'output Showplan XML generato utilizzando SET STATISTICS XML ON. Vengono popolati esclusivamente per la **Nonclustered Index Spool**, `Remote Query`, **Row Count Spool**, `Sort`, **Table Spool**, e  **Funzione con valori di tabella** operatori. **ActualRebinds** e **ActualRewinds** possono essere popolati per il `Assert` e **filtro** operatori quando il **StartupExpression** attributo è impostato su TRUE.  
  
 Quando **ActualRebinds** e **ActualRewinds** sono inclusi in uno Showplan XML, sono confrontabili con **EstimateRebinds** e **EstimateRewinds**. Quando non sono presenti, il numero di righe stimato (**EstimateRows**) è confrontabile con il numero effettivo di righe (**ActualRows**). Si noti che nell'output grafico effettivo Showplan viene visualizzato zero per le riassociazioni e i ripristini effettivi quando non presenti.  
  
 Un contatore correlato, **ActualEndOfScans**, è disponibile solo quando l'output Showplan viene generato utilizzando SET STATISTICS XML ON. Ogni volta che un operatore fisico raggiunge la fine del proprio flusso di dati, il contatore viene incrementato di uno. Un operatore fisico può raggiungere la fine del proprio flusso di dati, zero, una o più volte. Come per riassociazioni e ripristini, il numero di analisi terminate può essere maggiore di uno se l'operatore si trova nel lato interno di un join ciclico. Il numero di analisi terminate dovrebbe essere minore o uguale alla somma del numero di riassociazioni e ripristini.  
  
## <a name="mapping-physical-and-logical-operators"></a>Mapping di operatori logici e fisici  
 In Query Optimizer viene creato un piano di query che consiste in un albero di operatori logici. Dopo la creazione del piano, viene scelto l'operatore fisico più efficiente per ogni operatore logico. L'operatore fisico che implementerà un operatore logico viene individuato in base al costo.  
  
 In genere un'operazione logica può essere implementata da più operatori fisici. In alcuni casi rari tuttavia anche un operatore fisico può implementare più operazioni logiche.  
  
## <a name="operator-descriptions"></a>Descrizioni dell'operatore  
 In questa sezione vengono descritti gli operatori fisici e logici.  
  
|Icona del piano di esecuzione grafico|Operatore Showplan|Description|  
|-----------------------------------|-----------------------|-----------------|  
|None|`Aggregate`|L'operatore `Aggregate` calcola il valore di un'espressione che include MIN, MAX, SUM, COUNT o AVG. `Aggregate` può essere un operatore logico o fisico.|  
|![Icona dell'operatore Arithmetic Expression](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Icona dell'operatore Arithmetic Expression")|`Arithmetic Expression`|L'operatore `Arithmetic Expression` calcola un nuovo valore da valori esistenti in una riga. `Arithmetic Expression` non viene usato in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Icona dell'operatore Assert](../../2014/database-engine/media/assert-32x.gif "Icona dell'operatore Assert")|`Assert`|Il `Assert` operatore verifica una condizione. ad esempio convalida l'integrità referenziale oppure verifica che una sottoquery scalare restituisca una riga. Per ogni riga di input, il `Assert` operatore valuta l'espressione nella `Argument` colonna del piano di esecuzione. Se questa espressione restituisce NULL, la riga viene passata tramite l'operatore `Assert` e l'esecuzione della query procede. Se l'operazione restituisce un valore non NULL, verrà generato l'errore appropriato. Il `Assert` è un operatore fisico.|  
|![Icona dell'elemento di linguaggio Assign](../../2014/database-engine/media/assign-32.gif "Icona dell'elemento di linguaggio Assign")|`Assign`|Il `Assign` operatore assegna il valore di un'espressione o una costante a una variabile. `Assign` è un elemento di linguaggio.|  
|None|`Asnyc Concat`|Il `Asnyc Concat` operatore viene usato solo nelle query remote (query distribuite). È caratterizzato da *n* nodi figlio e un nodo padre. Alcuni nodi figlio sono normalmente computer remoti che partecipano a una query distribuita. `Asnyc Concat` problemi `open()` chiama contemporaneamente per tutti i figli e quindi applica una mappa di bit a ogni elemento figlio. Per ogni bit che corrisponde a 1, `Async Concat` invia le righe di output al nodo padre su richiesta.|  
|![Icona dell'operatore Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Icona dell'operatore Bitmap")|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] Usa il `Bitmap` operatore per implementare l'applicazione nei piani di query parallele di filtri bitmap. Applicazione di filtri velocizza l'esecuzione delle query eliminando le righe con valori di chiave che non possono produrre record di join prima di passare attraverso un altro operatore, ad esempio bitmap di `Parallelism` operatore. Un filtro bitmap utilizza una rappresentazione compatta di un set di valori da una tabella in una parte dell'albero dell'operatore per filtrare le righe da una seconda tabella in un'altra parte dell'albero. Rimuovendo le righe non necessarie quanto prima nella query, gli operatori successivi hanno meno righe su cui lavorare e le prestazioni complessive della query migliorano. Query Optimizer determina quando un bitmap è sufficientemente selettivo per essere utile e a quali operatori il filtro viene applicato. `Bitmap` è un operatore fisico.|  
|![Icona dell'operatore Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Icona dell'operatore Bitmap")|`Bitmap Create`|L'operatore `Bitmap Create` è visualizzato nell'output Showplan in cui vengono compilate le mappe di bit. `Bitmap Create` è un operatore logico.|  
|![Icona dell'operatore Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Icona dell'operatore Bookmark Lookup")|`Bookmark Lookup`|Il `Bookmark Lookup` operatore Usa un segnalibro (ID di riga o chiave di clustering) per cercare la riga corrispondente nella tabella o indice cluster. Il `Argument` colonna contiene l'etichetta segnalibro utilizzata per cercare la riga della tabella o indice cluster. Il `Argument` colonna contiene inoltre il nome della tabella o indice cluster in cui viene cercata la riga. Se viene visualizzata la clausola WITH PREFETCH nel `Argument` colonna, query processor ha determinato che si trova ottimale l'uso prelettura asincrona (read-ahead) durante la ricerca di segnalibri nella tabella o indice cluster.<br /><br /> `Bookmark Lookup` non viene usato in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]. `Clustered Index Seek` e `RID Lookup` consentono invece di eseguire la ricerca tramite segnalibro. Tale funzionalità è supportata inoltre dall'operatore `Key Lookup`.|  
|None|`Branch Repartition`|In un piano di query parallele sono presenti talvolta regioni concettuali di iteratori. È possibile eseguire tutti gli iteratori all'interno di tale regione mediante thread paralleli. Le regioni devono invece essere eseguite in modalità seriale. Alcuni iteratori `Parallelism` all'interno di una singola regione sono denominati `Branch Repartition`. L'operatore `Parallelism` al confine tra due regioni di questo tipo viene denominato `Segment Repartition`. `Branch Repartition` e `Segment Repartition` sono operatori logici.|  
|None|`Broadcast`|`Broadcast` ha un nodo figlio e *n* nodi padre. `Broadcast` invia le proprie righe di input a più consumer su richiesta. Ogni consumer riceve tutte le righe. Ad esempio, se tutti i consumer rappresentano i lati di un hash join, verranno compilate *n* copie delle tabelle hash.|  
|![Icona dell'operatore Build Hash](../../2014/database-engine/media/build-hash.gif "Icona dell'operatore Build Hash")|`Build Hash`|Indica la compilazione di una tabella hash in batch per un indice columnstore con ottimizzazione per la memoria xVelocity.|  
|None|`Cache`|`Cache` è una versione specializzata della **Spool** operatore. che consente di archiviare solo una riga di dati. `Cache` è un operatore logico. `Cache` non viene usato in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Icona dell'operatore Clustered Index Delete](../../2014/database-engine/media/clustered-index-delete-32x.gif "Icona dell'operatore Clustered Index Delete")|`Clustered Index Delete`|L'operatore `Clustered Index Delete` elimina righe dall'indice cluster specificato nella colonna dell'argomento del piano di esecuzione della query. Se un predicato WHERE :() nella colonna è presente l'argomento, quindi solo le righe che soddisfano il predicato vengono eliminati.`Clustered Index Delete` è un operatore fisico.|  
|![Icona dell'operatore Clustered Index Insert](../../2014/database-engine/media/clustered-index-insert-32x.gif "Icona dell'operatore Clustered Index Insert")|`Clustered Index Insert`|L'operatore Showplan `Clustered Index Insert` consente di inserire le righe dell'input generato nell'indice cluster specificato nella colonna Argument. La colonna Argument include inoltre il predicato SET:(), il quale indica il valore su cui è impostata ogni colonna. Se `Clustered Index Insert` sono disponibili figli per i valori insert, la riga inserita verrà recuperata dalla `Insert` operatore stesso.`Clustered Index Insert` è un operatore fisico.|  
|![Icona dell'operatore Clustered Index Merge](../../2014/database-engine/media/clustered-index-merge-32x.gif "Icona dell'operatore Clustered Index Merge")|**Clustered Index Merge**|L'operatore **Clustered Index Merge** applica un flusso di dati di unione a un indice cluster. L'operatore Elimina, aggiorna o inserisce righe dall'indice cluster specificato nella `Argument` colonna dell'operatore. L'operazione effettiva eseguita dipende dal valore di runtime il **azione** specificata nella colonna il `Argument` colonna dell'operatore. **Clustered Index Merge** è un operatore fisico.|  
|![Icona dell'operatore Clustered Index Scan](../../2014/database-engine/media/clustered-index-scan-32x.gif "Icona dell'operatore Clustered Index Scan")|`Clustered Index Scan`|L'operatore `Clustered Index Scan` esegue l'analisi dell'indice cluster specificato nella colonna Argument del piano di esecuzione della query. In presenza di un predicato facoltativo WHERE:(), vengono restituite solo le righe conformi al predicato. Se la colonna Argomento include la clausola ORDERED, Query Processor ha richiesto la restituzione dell'output delle righe nell'ordine utilizzato dall'indice cluster. Se la clausola ORDERED non è presente, il motore di archiviazione esegue l'analisi dell'indice in modo ottimale, senza necessariamente ordinare l'output. `Clustered Index Scan` è un operatore logico e fisico.|  
|![Icona dell'operatore Clustered Index Seek](../../2014/database-engine/media/clustered-index-seek-32x.gif "Icona dell'operatore Clustered Index Seek")|`Clustered Index Seek`|L'operatore `Clustered Index Seek` utilizza le funzionalità di ricerca degli indici per recuperare righe da un indice cluster. Il `Argument` colonna contiene il nome dell'indice cluster in uso e il predicato SEEK :(). Il motore di archiviazione utilizza l'indice per elaborare soltanto le righe conformi al predicato SEEK:(). Può inoltre includere un predicato WHERE:() in cui il motore di archiviazione valuta tutte le righe che sono conformi al predicato SEEK:(). Si tratta però di un predicato facoltativo, che non utilizza gli indici per completare l'elaborazione.<br /><br /> Se il `Argument` colonna contiene la clausola ORDERED, query processor ha determinato che le righe devono essere restituite nello stesso ordine in cui l'indice cluster con essi. Se la clausola ORDERED non è presente, il motore di archiviazione esegue la ricerca nell'indice in modo ottimale, senza necessariamente ordinare l'output. Il mantenimento dell'ordinamento dell'output può dare come risultato un livello di efficienza minore rispetto alla restituzione di output non ordinato. Quando viene visualizzata la parola chiave LOOKUP, è in esecuzione una ricerca tramite segnalibro. Nelle [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] e versioni successive, il `Key Lookup` ricerca tramite segnalibro è fornita dall'operatore. `Clustered Index Seek` è un operatore logico e fisico.|  
|![Icona dell'operatore Clustered Index Update](../../2014/database-engine/media/clustered-index-update-32x.gif "Icona dell'operatore Clustered Index Update")|`Clustered Index Update`|Il `Clustered Index Update` operatore Aggiorna le righe di input nell'indice cluster specificato nella `Argument` colonna. Se un predicato WHERE :() è presente, solo le righe che soddisfano il predicato vengono aggiornati. Se è stato specificato un predicato SET:(), ogni colonna aggiornata viene impostata su tale valore. Se è disponibile un predicato DEFINE:(), vengono elencati i valori definiti da tale operatore. Un riferimento a tali valori può essere presente nella clausola SET o altrove nell'operatore o nella query. `Clustered Index Update` è un operatore logico e fisico.|  
|![Icona dell'operatore Collapse](../../2014/database-engine/media/collapse-32x.gif "Icona dell'operatore Collapse")|`Collapse`|L'operatore `Collapse` ottimizza l'elaborazione degli aggiornamenti. Quando viene eseguito un aggiornamento, è possibile suddividerlo (usando il `Split` operator) in un'operazione di eliminazione e un'istruzione insert. Il `Argument` colonna contiene un clausola GROUP BY :() che specifica un elenco di colonne chiave. Se in Query Processor vengono rilevate righe adiacenti che eliminano e inseriscono gli stessi valori chiave, queste operazioni separate vengono sostituite con una singola operazione di aggiornamento più efficiente. `Collapse` è un operatore logico e fisico.|  
|![Analisi indice Columnstore](../../2014/database-engine/media/columnstoreindexscan.gif "Analisi indice Columnstore")|`Columnstore Index Scan`|Il `Columnstore Index Scan` operatore esegue la scansione dell'indice columnstore specificato nella `Argument` colonna del piano di esecuzione della query.|  
|![Icona dell'operatore Compute Scalar](../../2014/database-engine/media/compute-scalar-32x.gif "Icona dell'operatore Compute Scalar")|`Compute Scalar`|Il `Compute Scalar` operatore valuta un'espressione e produce un valore scalare calcolato. Tale valore può essere restituito all'utente e/o utilizzato come riferimento in altre parti della query, ad esempio in un predicato di filtro o di join. `Compute Scalar` è un operatore logico e fisico.<br /><br /> `Compute Scalar` gli operatori che vengono visualizzati negli Showplan generati da SET STATISTICS XML potrebbero non includere il `RunTimeInformation` elemento. Negli Showplan grafici è possibile che **Actual Rows**, **Actual Rebinds**e **Actual Rewinds** non siano presenti nella finestra **Proprietà** quando l'opzione **Includi piano di esecuzione effettivo** è selezionata in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]. Questo indica che, sebbene questi operatori fossero utilizzati nel piano di query compilato, la loro funzione è stata svolta da altri operatori nel piano di query di run-time. Si noti inoltre che il numero di esecuzioni nell'output di Showplan generato da SET STATISTICS PROFILE equivale alla somma di riassociazioni e ripristini in Showplan generati da SET STATISTICS XML.|  
|![Icona dell'operatore Concatenation](../../2014/database-engine/media/concatenation-32x.gif "Icona dell'operatore Concatenation")|**Concatenation**|L'operatore **Concatenation** esegue l'analisi di più input e restituisce ogni riga sottoposta ad analisi. L'operatore**Concatenation** in genere viene utilizzato per implementare il costrutto [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL. L'operatore fisico **Concatenation** prevede uno o più input e un output e copia le righe dal primo flusso di input nel flusso di output, quindi ripete l'operazione per ogni flusso di input aggiuntivo. **Concatenation** è un operatore logico e fisico.|  
|![Icona dell'operatore Constant Scan](../../2014/database-engine/media/constant-scan-32x.gif "Icona dell'operatore Constant Scan")|`Constant Scan`|Il `Constant Scan` operatore inserisce uno o più righe con valore costante in una query. Oggetto `Compute Scalar` operatore viene spesso utilizzato dopo una `Constant Scan` per aggiungere colonne a una riga creata dal `Constant Scan` operatore.|  
|![Icona dell'elemento di linguaggio Convert (motore di database)](../../2014/database-engine/media/convert-32x.gif "Icona dell'elemento di linguaggio Convert (motore di database)")|`Convert`|L'operatore `Convert` converte un tipo di dati scalare in un altro. `Convert` è un elemento di linguaggio.|  
|None|`Cross Join`|L'operatore `Cross Join` crea un join tra ogni riga del primo input (superiore) e ogni riga del secondo input (inferiore). `Cross Join` è un operatore logico.|  
|![Icona generica dell'operatore Cursor](../../2014/database-engine/media/cursor-catch-all.gif "Icona generica dell'operatore Cursor")|`catchall`|L'icona generica viene visualizzata quando la logica che produce Showplan grafici non è in grado di individuare un'icona appropriata per l'iteratore. L'icona generica non indica necessariamente una condizione di errore. Sono disponibili tre icone generiche: blu (per gli iteratori), arancione (per i cursori) e verde (per gli elementi del linguaggio [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|None|**Cursore**|Gli operatori logici e fisici **Cursor** consentono di descrivere le modalità di esecuzione di una query o di un aggiornamento che implicano operazioni con i cursori. Gli operatori fisici descrivono l'algoritmo di implementazione fisica utilizzato per l'elaborazione del cursore, ad esempio l'utilizzo di un cursore gestito da keyset. Ogni passaggio dell'esecuzione di un cursore implica un operatore fisico. Gli operatori logici descrivono una proprietà del cursore, ad esempio la proprietà di sola lettura.<br /><br /> Gli operatori logici includono Asynchronous, Optimistic, Primary, Read Only, Scroll Locks e Secondary and Synchronous,<br /><br /> mentre quelli fisici includono Dynamic, Fetch Query, Keyset, Population Query, Refresh Query e Snapshot.|  
|![Icona dell'elemento di linguaggio Declare](../../2014/database-engine/media/declare-32x.gif "Icona dell'elemento di linguaggio Declare")|`Declare`|Il `Declare` operatore alloca una variabile locale nel piano di query. `Declare` è un elemento di linguaggio.|  
|![Icona dell'operatore Delete (motore di database)](../../2014/database-engine/media/delete-32x.gif "Icona dell'operatore Delete (motore di database)")|`Delete`|Il `Delete` operatore Elimina da un oggetto le righe conformi al predicato facoltativo nel `Argument` colonna.|  
|![Icona dell'operatore Deleted Scan](../../2014/database-engine/media/delete-scan-32x.gif "Icona dell'operatore Deleted Scan")|`Deleted Scan`|L'operatore `Deleted Scan` esegue l'analisi della tabella eliminata all'interno di un trigger.|  
|None|`Distinct`|L'operatore `Distinct` rimuove i duplicati da un set di righe o da una raccolta di valori. `Distinct` è un operatore logico.|  
|None|`Distinct Sort`|Il `Distinct Sort` operatore logico esegue l'analisi dell'input rimuovendo i duplicati e l'ordinamento per le colonne specificate nella DISTINCT ORDER BY :() predicato del `Argument` colonna. `Distinct Sort` è un operatore logico.|  
|![Icona dell'operatore di parallelismo Distribute Streams](../../2014/database-engine/media/parallelism-distribute-stream.gif "Icona dell'operatore di parallelismo Distribute Streams")|**Distribute Streams**|L'operatore **Distribute Streams** viene utilizzato esclusivamente in piani di query parallele. L'operatore **Distribute Streams** elabora un singolo flusso di input di record e produce più flussi di output. Il contenuto e il formato del record non vengono modificati. Ogni record del flusso di input appare in uno dei flussi di output. L'operatore mantiene automaticamente l'ordine relativo dei record di input nei flussi di output. In genere, l'appartenenza di un record di input a un flusso di output viene determinata tramite un'operazione di hashing.<br /><br /> Se l'output è partizionato, la `Argument` colonna contiene un predicato PARTITION COLUMNS :() e le colonne di partizionamento. **Distribute Streams** è un operatore logico.|  
|![Icona dell'operatore Dynamic per il cursore](../../2014/database-engine/media/dynamic-32x.gif "Icona dell'operatore Dynamic per il cursore")|`Dynamic`|Il `Dynamic` operatore Usa un cursore che può visualizzare tutte le modifiche apportate da altri utenti.|  
|![Icona dell'operatore Spool](../../2014/database-engine/media/spool-32x.gif "Icona dell'operatore Spool")|**Eager Spool**|Il **Eager Spool** operatore elabora l'intero input e archivia ogni riga in un oggetto temporaneo nascosto memorizzato nel `tempdb` database. Se l'operatore viene riavvolto (ad esempio, tramite un `Nested Loops` operator) ma non la riassociazione è necessaria, i dati di spooling viene usati invece di eseguire l'input. Se è necessario ripetere l'associazione, i dati di spooling vengono eliminati e l'oggetto di spooling viene ricompilato tramite una nuova analisi dell'input riassociato. L'operatore **Eager Spool** compila il proprio file di spooling nel modo seguente. Quando l'operatore principale dello spooling richiede la prima riga, l'operatore di spooling utilizza tutte le righe dal proprio operatore di input e le archivia nello spooling. **Eager Spool** è un operatore logico.|  
|![Icona dell'operatore Fetch Query per il cursore](../../2014/database-engine/media/fetch-query-32x.gif "Icona dell'operatore Fetch Query per il cursore")|`Fetch Query`|Il `Fetch Query` operatore recupera le righe quando viene eseguita un'operazione di recupero su un cursore.|  
|![Icona dell'operatore Filter (motore di database)](../../2014/database-engine/media/filter-32x.gif "Icona dell'operatore Filter (motore di database)")|**Filter**|Il **filtro** operatore esegue l'analisi dell'input restituendo soltanto le righe che soddisfano l'espressione di filtro (predicato) che viene visualizzato nei `Argument` colonna.|  
|None|`Flow Distinct`|Il `Flow Distinct` operatore logico esegue l'analisi dell'input e rimuove i duplicati. Mentre il `Distinct` operatore elabora l'intero input prima che venga generato alcun output, il **FlowDistinct** operatore restituisce ogni riga come viene ottenuta dall'input (a meno che non che la riga è un duplicato, nel qual caso vengono eliminate).|  
|None|`Full Outer Join`|Il `Full Outer Join` operatore logico restituisce ogni riga che soddisfa il predicato di join (superiore) del primo input con ogni riga (inferiore) del secondo input. L'operatore restituisce inoltre:<br /><br /> - Righe del primo input senza corrispondenze nel secondo input.<br /><br /> - Righe del secondo input senza corrispondenze nel primo input.<br /><br /> <br /><br /> L'input che non include valori corrispondenti viene restituito come valore Null. `Full Outer Join` è un operatore logico.|  
|![Icona dell'operatore di parallelismo Gather Streams](../../2014/database-engine/media/parallelism-32x.gif "Icona dell'operatore di parallelismo Gather Streams")|**Gather Streams**|L'operatore logico **Gather Streams** viene utilizzato esclusivamente in piani di query paralleli. **Tale operatore** elabora vari flussi di input e quindi produce un unico flusso di output di record derivati dalla combinazione dei flussi di input. Il contenuto e il formato del record non vengono modificati. Se l'operatore prevede l'ordinamento, è necessario che tutti i flussi di input siano ordinati. Se l'output è ordinato, la `Argument` colonna contiene un predicato ORDER BY :() e i nomi delle colonne ordinate. **Gather Streams** è un operatore logico.|  
|![Icona dell'operatore Hash Match](../../2014/database-engine/media/hash-match-32x.gif "Icona dell'operatore Hash Match")|`Hash Match`|L'operatore `Hash Match` compila una tabella hash calcolando un valore hash per ogni riga dall'input di compilazione. Un predicato HASH :() con un elenco di colonne utilizzate per creare un valore hash viene visualizzato nei `Argument` colonna. Per ogni riga probe, quando applicabile, viene calcolato un valore hash (tramite la stessa funzione di hashing) e quindi vengono cercate corrispondenze nella tabella hash. Se è presente un predicato residuo (identificato da RESIDUAL :() nella `Argument` colonna), per essere considerato una corrispondenza delle righe deve essere soddisfatto anche tale predicato. Il funzionamento dipende dell'operazione logica eseguita:<br /><br /> Per tutti i join, il primo input (superiore) viene utilizzato per la compilazione della tabella hash e il secondo input (inferiore) per l'esecuzione del probe nella tabella hash. L'output delle corrispondenze (o delle mancate corrispondenze) viene eseguito in base a quanto previsto dal tipo di join. Se più join utilizzano la stessa colonna di join, le operazioni sono raggruppate in un gruppo di hash.<br /><br /> Per gli operatori Distinct o Aggregate l'input viene utilizzato per la compilazione della tabella hash (con rimozione dei duplicati e calcolo di eventuali espressioni di aggregazione). Quando viene creata la tabella hash, vengono eseguiti l'analisi della tabella e il successivo output di tutte le voci.<br /><br /> Per l'operatore Union, il primo input viene utilizzato per la compilazione della tabella hash (con rimozione dei duplicati). Il secondo input (che non deve includere duplicati) viene utilizzato per l'esecuzione del probe della tabella hash, seguita dalla restituzione di tutte le righe senza corrispondenze, dall'analisi della tabella hash e infine dalla restituzione di tutte le voci.<br /><br /> <br /><br /> `Hash Match` è un operatore fisico.|  
|![Icona dell'elemento di linguaggio If](../../2014/database-engine/media/if-32x.gif "Icona dell'elemento di linguaggio If")|`If`|Il `If` operatore esegue un'elaborazione condizionale basata su un'espressione. `If` è un elemento di linguaggio.|  
|None|`Inner Join`|Il `Inner Join` operatore logico restituisce ogni riga che soddisfa il join del primo input (superiore) con (inferiore) del secondo input.|  
|![Icona dell'operatore Insert (motore di database)](../../2014/database-engine/media/insert-32x.gif "Icona dell'operatore Insert (motore di database)")|`Insert`|Il `Insert` operatore logico inserisce ogni riga dal proprio input nell'oggetto specificato nel `Argument` colonna. L'operatore fisico può essere il `Table Insert`, `Index Insert`, o `Clustered Index Insert` operatore.|  
|![Icona dell'operatore Inserted Scan](../../2014/database-engine/media/inserted-scan-32x.gif "Icona dell'operatore Inserted Scan")|**Inserted Scan**|L'operatore **Inserted Scan** esegue l'analisi della tabella **inserted** . **Inserted Scan** è un operatore logico e fisico.|  
|![Icona dell'elemento di linguaggio Intrinsic](../../2014/database-engine/media/intrinsic-32x.gif "Icona dell'elemento di linguaggio Intrinsic")|`Intrinsic`|Il `Intrinsic` operatore richiama interna [!INCLUDE[tsql](../includes/tsql-md.md)] (funzione). `Intrinsic` è un elemento di linguaggio.|  
|![Icona generica dell'operatore Iterator](../../2014/database-engine/media/iterator-catch-all.gif "Icona generica dell'operatore Iterator")|`Iterator`|L'icona generica per `Iterator` viene visualizzata quando la logica che produce Showplan grafici non è in grado di individuare un'icona appropriata per l'iteratore. L'icona generica non indica necessariamente una condizione di errore. Sono disponibili tre icone generiche: blu (per gli iteratori), arancione (per i cursori) e verde (per i costrutti del linguaggio [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Icona dell'operatore Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Icona dell'operatore Bookmark Lookup")|`Key Lookup`|Il `Key Lookup` operatore è una ricerca tramite segnalibro per una tabella con un indice cluster. Il `Argument` colonna contiene il nome dell'indice cluster e la chiave di clustering utilizzata per cercare la riga nell'indice cluster. `Key Lookup` è sempre accompagnato da un `Nested Loops` operatore. Se viene visualizzata la clausola WITH PREFETCH nel `Argument` colonna, query processor ha determinato che si trova ottimale l'uso prelettura asincrona (read-ahead) durante la ricerca di segnalibri nell'indice cluster.<br /><br /> L'uso di un `Key Lookup` operatore in un piano di query indica che la query potrebbe trarre vantaggio dall'ottimizzazione delle prestazioni. Le prestazioni della query, ad esempio, potrebbero essere migliorate con l'aggiunta di un indice di copertura.|  
|![Icona dell'operatore Keyset per il cursore](../../2014/database-engine/media/keyset-32x.gif "Icona dell'operatore Keyset per il cursore")|`Keyset`|L'operatore `Keyset` utilizza un cursore in grado di riconoscere gli aggiornamenti ma non gli inserimenti eseguiti da altri.|  
|![Icona generica per Language Element](../../2014/database-engine/media/language-construct-catch-all.gif "Icona generica per Language Element")|`Language Element`|L'icona generica per `Language Element` viene visualizzata quando la logica che produce Showplan grafici non è in grado di individuare un'icona appropriata per l'iteratore. L'icona generica non indica necessariamente una condizione di errore. Sono disponibili tre icone generiche: blu (per gli iteratori), arancione (per i cursori) e verde (per i costrutti del linguaggio [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Icona dell'operatore Spool](../../2014/database-engine/media/spool-32x.gif "Icona dell'operatore Spool")|**Lazy Spool**|Il **Lazy Spool** operatore logico archivia ogni riga dell'input in un oggetto temporaneo nascosto memorizzato nel `tempdb` database. Se l'operatore viene riavvolto (ad esempio, tramite un `Nested Loops` operator) ma non la riassociazione è necessaria, i dati di spooling viene usati invece di eseguire l'input. Se è necessario ripetere l'associazione, i dati di spooling vengono eliminati e l'oggetto di spooling viene ricompilato tramite una nuova analisi dell'input riassociato. L'operatore **Lazy Spool** compila il file di spooling con un'elaborazione lenta: ogni volta che l'operatore padre dello spooling richiede una riga, anziché elaborare contemporaneamente tutte le righe, l'operatore di spooling ottiene una riga dal relativo operatore di input e la archivia nel file di spooling. Lazy Spool è un operatore logico.|  
|None|`Left Anti Semi Join`|L'operatore `Left Anti Semi Join` restituisce ogni riga del primo input (superiore) alla quale non corrisponde nessuna riga del secondo input (inferiore). Se è presente alcun predicato di join nel `Argument` colonna, ogni riga contiene una riga corrispondente. `Left Anti Semi Join` è un operatore logico.|  
|None|`Left Outer Join`|L'operatore `Left Outer Join` restituisce ogni riga che soddisfa il join del primo input (superiore) con il secondo input (inferiore). L'operatore restituisce inoltre ogni riga del primo input alla quale non corrisponde una riga nel secondo input. Le righe senza corrispondenza nel secondo input vengono restituite come valori Null. Se è presente alcun predicato di join nel `Argument` colonna, ogni riga contiene una riga corrispondente. `Left Outer Join` è un operatore logico.|  
|None|`Left Semi Join`|Il `Left Semi Join` operatore restituisce ogni riga del primo input (superiore) quando esiste una riga corrisponda nel secondo input (inferiore). Se è presente alcun predicato di join nel `Argument` colonna, ogni riga contiene una riga corrispondente. `Left Semi Join` è un operatore logico.|  
|![Icona dell'operatore Log Row Scan](../../2014/database-engine/media/log-row-scan-32x.gif "Icona dell'operatore Log Row Scan")|`Log Row Scan`|Il `Log Row Scan` operatore esegue l'analisi del log delle transazioni. `Log Row Scan` è un operatore logico e fisico.|  
|![Icona dell'operatore Merge Interval](../../2014/database-engine/media/merge-interval-32x.gif "Icona dell'operatore Merge Interval")|`Merge Interval`|Il `Merge Interval` operatore unisce più intervalli (potenzialmente sovrapposti) restituisce intervalli minimi, non sovrapposte vengono quindi usate per ricerca di voci di indice. Questo operatore appare in genere sopra uno o più `Compute Scalar` operatori `Constant Scan` operatori creano gli intervalli (rappresentati da colonne di una riga) uniti dall'operatore. `Merge Interval` è un operatore logico e fisico.|  
|![Icona dell'operatore Merge Join](../../2014/database-engine/media/merge-join-32x.gif "Icona dell'operatore Merge Join")|**Merge Join**|L'operatore **Merge Join** esegue le operazioni di inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join e union logical.<br /><br /> Nel `Argument` colonna, il **Merge Join** operatore contiene un predicato MERGE :() se è in esecuzione un join uno-a-molti o molti a molti MERGE :() predicato se l'operazione è in esecuzione un join molti-a-molti. Il `Argument` colonna include inoltre un elenco delimitato da virgole di colonne utilizzate per eseguire l'operazione. L'operatore **Merge Join** richiede due input ordinati in base alle rispettive colonne, eventualmente tramite l'inserimento di operazioni di ordinamento esplicite nel piano di query. Merge Join è particolarmente efficace se non è richiesto l'ordinamento esplicito, ad esempio se nel database è presente un indice ad albero B adeguato o se il tipo di ordinamento è utilizzabile per più operazioni, quali merge join e raggruppamenti con rollup. **Merge Join** è un operatore fisico.|  
|![Icona dell'operatore Nested Loops](../../2014/database-engine/media/nested-loops-32x.gif "Icona dell'operatore Nested Loops")|`Nested Loops`|L'operatore `Nested Loops` esegue le operazioni logiche di inner join, left outer join, left semi join e left anti semi join. I join a cicli annidati eseguono una ricerca nella tabella interna per ogni riga della tabella esterna, usando generalmente un indice. Query processor determina, in base ai costi previsti, se ordinare l'input esterno per migliorare le ricerche basate sull'indice rispetto all'input interno. Tutte le righe che soddisfano il predicato (facoltativo) nella `Argument` colonna vengono restituiti a seconda dei casi, l'operazione logica eseguita in base. `Nested Loops` è un operatore fisico.|  
|![Icona dell'operatore Nonclustered Index Delete](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Icona dell'operatore Nonclustered Index Delete")|`Nonclustered Index Delete`|Il `Nonclustered Index Delete` operatore consente di eliminare le righe di input dall'indice non cluster specificato nella `Argument` colonna. `Nonclustered Index Delete` è un operatore fisico.|  
|![Icona dell'operatore Index Insert per indice non cluster](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Icona dell'operatore Index Insert per indice non cluster")|`Index Insert`|Il `Index Insert` operatore inserisce righe dal proprio input nell'indice non cluster specificato nella `Argument` colonna. Il `Argument` colonna include inoltre un predicato SET :(), che indica il valore su cui è impostata ogni colonna. `Index Insert` è un operatore fisico.|  
|![Icona dell'operatore Index Scan per indice non cluster](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Icona dell'operatore Index Scan per indice non cluster")|`Index Scan`|Il `Index Scan` operatore recupera tutte le righe dall'indice non cluster specificato nella `Argument` colonna. Se è facoltativo in cui :() predicato viene visualizzato nei `Argument` colonna, vengono restituite solo le righe che soddisfanno il predicato. `Index Scan` è un operatore logico e fisico.|  
|![Icona dell'operatore Index Seek per indice non cluster](../../2014/database-engine/media/index-seek-32x.gif "Icona dell'operatore Index Seek per indice non cluster")|`Index Seek`|Il `Index Seek` operatore Usa la funzionalità di ricerca degli indici per recuperare righe da un indice non cluster. Il `Argument` colonna contiene il nome dell'indice non cluster in uso. La colonna include inoltre il predicato SEEK:(). Il motore di archiviazione utilizza l'indice per elaborare soltanto le righe conformi al predicato SEEK:() Facoltativamente esso può includere un predicato WHERE:(), che verrà valutato dal motore di archiviazione rispetto a tutte le righe conformi al predicato SEEK:() (non utilizza gli indici per tale operazione). Se il `Argument` colonna contiene la clausola ORDERED, query processor ha determinato che le righe devono essere restituite nello stesso ordine in cui l'indice non cluster con essi. In assenza della clausola ORDERED, il motore di archiviazione esegue una ricerca nell'indice utilizzando il metodo ottimale (con output non necessariamente ordinato). Il mantenimento dell'ordinamento dell'output può dare come risultato un livello di efficienza minore rispetto alla restituzione di output non ordinato. `Index Seek` è un operatore logico e fisico.|  
|![Icona dell'operatore Index Spool per indice non cluster](../../2014/database-engine/media/index-spool-32x.gif "Icona dell'operatore Index Spool per indice non cluster")|**Index Spool**|Il **Index Spool** operatore fisico contiene un predicato SEEK :() nella `Argument` colonna. Il **Index Spool** operatore analizza le righe di input e inserisce una copia di ogni riga in un file di spooling nascosto (archiviato nel `tempdb` database e con la durata della query) e compila un indice non cluster sulle righe. Ciò consente di utilizzare la funzionalità di ricerca degli indici per restituire solo le righe che soddisfano il predicato SEEK:(). Se l'operatore viene riavvolto (ad esempio, tramite un `Nested Loops` operator) ma non la riassociazione è necessaria, i dati di spooling viene usati invece di eseguire l'input.|  
|![Icona dell'operatore Nonclustered Index Update](../../2014/database-engine/media/nonclust-index-update-32x.gif "Icona dell'operatore Nonclustered Index Update")|`Nonclustered Index Update`|Il `Nonclustered Index Update` operatore fisico vengono aggiornate le righe dal proprio input nell'indice non cluster specificato nella `Argument` colonna. Se è stato specificato un predicato SET:(), ogni colonna aggiornata viene impostata su tale valore. `Nonclustered Index Update` è un operatore fisico.|  
|![Icona dell'operatore Online Index Insert](../../2014/database-engine/media/online-index-32x.gif "Icona dell'operatore Online Index Insert")|**Online Index Insert**|L'operatore fisico **Online Index Insert** indica che la creazione, la modifica o l'eliminazione di un indice viene eseguita online, ovvero che i dati della tabella sottostante rimangono disponibili agli utenti durante l'operazione sull'indice.|  
|None|`Parallelism`|Il `Parallelism` eseguita operatore distribute streams, gather flussi e repartition streams operazioni logiche. Il `Argument` colonne possono contenere un predicato PARTITION COLUMNS :() con un elenco delimitato da virgole delle colonne partizionate. Il `Argument` colonne possono anche contenere un predicato ORDER BY :(), elenca le colonne per mantenere l'ordinamento durante il partizionamento. `Parallelism` è un operatore fisico.<br /><br /> Nota: Se una query è stata compilata come parallela, ma in fase di esecuzione viene eseguita come seriale, l'output Showplan generato da SET STATISTICS XML o utilizzando il **Includi piano di esecuzione effettivo** opzione [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] non conterrà il `RunTimeInformation` (elemento) per il `Parallelism` operatore. Nell'output di SET STATISTICS PROFILE i conteggi delle righe effettivi e il numero effettivo delle esecuzioni indicheranno zero per il `Parallelism` operatore. Quando si verifica una delle due condizioni, significa che il `Parallelism` operatore è stato usato solo durante la compilazione di query e non nel piano di query in fase di esecuzione. Si noti che talvolta i piani di query parallele vengono eseguiti in serie se il carico simultaneo del server è elevato.|  
|![Icona dell'operatore Parameter Table Scan](../../2014/database-engine/media/parameter-table-scan-32x.gif "Icona dell'operatore Parameter Table Scan")|`Parameter Table Scan`|Il `Parameter Table Scan` operatore analizza una tabella che funge da parametro nella query corrente. In genere questa funzionalità è utilizzata per le query INSERT all'interno di una stored procedure. `Parameter Table Scan` è un operatore logico e fisico.|  
|None|**Partial Aggregate**|L'operatore**Partial Aggregate** è utilizzato nei piani paralleli. Applica una funzione di aggregazione al maggior numero possibile di righe di input in modo che la scrittura su disco (operazione nota come "spill") non sia necessaria. `Hash Match` è l'unico operatore fisico (iteratore) che implementa l'aggregazione delle partizioni. **Partial Aggregate** è un operatore logico.|  
|![Icona dell'operatore Population Query per il cursore](../../2014/database-engine/media/poulation-query-32x.gif "Icona dell'operatore Population Query per il cursore")|`Population Query`|All'apertura di un cursore, l'operatore `Population Query` esegue il popolamento della relativa tabella di lavoro.|  
|![Icona dell'operatore Refresh Query per il cursore](../../2014/database-engine/media/refresh-query-32x.gif "Icona dell'operatore Refresh Query per il cursore")|`Refresh Query`|L'operatore `Refresh Query` recupera i dati correnti per le righe nel buffer di recupero.|  
|![Icona dell'operatore Remote Delete](../../2014/database-engine/media/remote-delete-32x.gif "Icona dell'operatore Remote Delete")|`Remote Delete`|Il `Remote Delete` operatore consente di eliminare le righe di input da un oggetto remoto. `Remote Delete` è un operatore logico e fisico.|  
|![Operatore Showplan Remote Index Seek](../../2014/database-engine/media/remote-index-scan-32x.gif "Operatore Showplan Remote Index Seek")|**Remote Index Scan**|L'operatore **Remote Index Scan** analizza l'indice remoto specificato nella colonna Argument. **Remote Insert Scan** è un operatore logico e fisico.|  
|![Operatore Showplan Remote Index Seek](../../2014/database-engine/media/remote-index-seek-32x.gif "Operatore Showplan Remote Index Seek")|**Remote Index Seek**|L'operatore **Remote Index Seek** utilizza le capacità di ricerca di un oggetto Index remoto per il recupero di righe. Il `Argument` colonna contiene il nome dell'indice remoto utilizzato e il predicato SEEK :(). **Remote Insert Seek** è un operatore logico fisico.|  
|![Icona dell'operatore Remote Insert](../../2014/database-engine/media/remote-insert-32x.gif "Icona dell'operatore Remote Insert")|**Remote Insert**|L'operatore **Remote Insert** inserisce le righe di input in un oggetto remoto. **Remote Insert** è un operatore logico e fisico.|  
|![Icona dell'operatore Remote Query](../../2014/database-engine/media/remote-query-32x.gif "Icona dell'operatore Remote Query")|`Remote Query`|Il `Remote Query` operatore invia una query a un'origine remota. Il testo della query inviata al server remoto verrà visualizzato il `Argument` colonna. `Remote Query` è un operatore logico e fisico.|  
|![Icona dell'operatore Remote Scan](../../2014/database-engine/media/remote-scan-32x.gif "Icona dell'operatore Remote Scan")|`Remote Scan`|Il `Remote Scan` operatore esegue la scansione di un oggetto remoto. Il nome dell'oggetto remoto appare nella `Argument` colonna. `Remote Scan` è un operatore logico e fisico.|  
|![Icona dell'operatore Remote Update](../../2014/database-engine/media/remote-update-32x.gif "Icona dell'operatore Remote Update")|`Remote Update`|Il `Remote Update` operatore Aggiorna le righe di input in un oggetto remoto. `Remote Update` è un operatore logico e fisico.|  
|![Icona dell'operatore di parallelismo Repartition Streams](../../2014/database-engine/media/parallelism-repartition-stream.gif "Icona dell'operatore di parallelismo Repartition Streams")|**Repartition Streams**|L'operatore **Repartition Streams** elabora più flussi e restituisce più flussi di record. Il contenuto e il formato del record non vengono modificati. Se Query Optimizer utilizza un filtro bitmap, il numero di righe nel flusso di output è ridotto. Ogni record di un flusso di input viene inserito in un flusso di output. Se l'operatore prevede il rispetto dell'ordine, è necessario che tutti i flussi di input risultino ordinati e vengano uniti in vari flussi di output ordinati. Se l'output è partizionato, la `Argument` colonna contiene un predicato PARTITION COLUMNS :() e le colonne di partizionamento. Se l'output è ordinato, la `Argument` colonna contiene un predicato ORDER BY :() e le colonne da ordinare. **Repartition Streams** è un operatore logico. L'operatore viene utilizzato solo nei piani di query parallele.|  
|![Icona dell'elemento di linguaggio Result](../../2014/database-engine/media/result-32x.gif "Icona dell'elemento di linguaggio Result")|`Result`|Il `Result` operatore corrisponde ai dati restituiti alla fine di un piano di query. ed è in genere l'elemento radice di uno Showplan. `Result` è un elemento di linguaggio.|  
|![Icona dell'operatore RID Lookup](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "Icona dell'operatore RID Lookup")|`RID Lookup`|`RID Lookup` è una ricerca tramite segnalibro in un heap mediante un identificatore di riga (RID). Il `Argument` colonna contiene l'etichetta segnalibro utilizzata per cercare la riga nella tabella e il nome della tabella in cui viene cercata la riga. `RID Lookup` è sempre utilizzato in combinazione con un operatore NESTED LOOP JOIN. `RID Lookup` è un operatore fisico. Per ulteriori informazioni sulle ricerche tramite segnalibro, vedere "[Bookmark Lookup](http://go.microsoft.com/fwlink/?LinkId=132568)" nel blog su SQL Server in MSDN.|  
|None|`Right Anti Semi Join`|Il `Right Anti Semi Join` operatore restituisce ogni riga del secondo input (inferiore) quando una riga corrispondente nella prima (superiore) di input non esiste. Una riga corrispondente è definita come una riga che soddisfa il predicato nel `Argument` colonna (se è presente alcun predicato, ogni riga viene interpretata come riga corrispondente). `Right Anti Semi Join` è un operatore logico.|  
|None|`Right Outer Join`|Il `Right Outer Join` operatore restituisce ogni riga che soddisfa il join del secondo (inferiore) di input con ogni riga corrispondente (superiore) del primo input. L'operatore restituisce inoltre ogni riga del secondo input alla quale non corrisponde una riga nel primo input, con join a valori NULL. Se è presente alcun predicato di join nel `Argument` colonna, ogni riga contiene una riga corrispondente. `Right Outer Join` è un operatore logico.|  
|None|`Right Semi Join`|L'operatore `Right Semi Join` restituisce ogni riga del secondo input (inferiore) alla quale corrisponde una riga nel primo input (superiore). Se è presente alcun predicato di join nel `Argument` colonna, ogni riga contiene una riga corrispondente. `Right Semi Join` è un operatore logico.|  
|![Icona dell'operatore Row Count Spool](../../2014/database-engine/media/remote-count-spool-32x.gif "Icona dell'operatore Row Count Spool")|**Row Count Spool**|L'operatore **Row Count Spool** esegue l'analisi dell'input calcolando e restituendo il numero di righe presenti senza alcun dato. Questo operatore viene utilizzato quando è importante verificare l'esistenza delle righe anziché i dati contenuti nelle righe. Ad esempio, se un `Nested Loops` operatore esegue un'operazione di left semi join e il predicato di join è relativo all'input interno, può essere inserito uno spooler di conteggio righe nella parte superiore dell'input interno del `Nested Loops` operatore. Il `Nested Loops` operatore può determinare il numero di righe di output indicate dallo spooler di conteggio righe (perché i dati effettivi dal lato interno non sono necessario) per determinare se restituire la riga esterna. **Row Count Spool** è un operatore fisico.|  
|![Icona dell'operatore Segment](../../2014/database-engine/media/segment-32x.gif "Icona dell'operatore Segment")|**Segment**|**Segment** è un operatore fisico e logico L'operatore divide il set di input in segmenti in base al valore di una o più colonne Tali colonne vengono visualizzate come argomenti nell'operatore **Segment** e quindi restituisce un segmento per volta.|  
|None|`Segment Repartition`|In un piano di query parallele sono presenti talvolta regioni concettuali di iteratori. È possibile eseguire tutti gli iteratori all'interno di tale regione mediante thread paralleli. Le regioni devono invece essere eseguite in modalità seriale. Alcuni iteratori `Parallelism` all'interno di una singola regione sono denominati `Branch Repartition`. L'operatore `Parallelism` al confine tra due regioni di questo tipo viene denominato `Segment Repartition`. `Branch Repartition` e `Segment Repartition` sono operatori logici.|  
|![Icona dell'operatore Sequence](../../2014/database-engine/media/sequence-32x.gif "Icona dell'operatore Sequence")|`Sequence`|Il `Sequence` operatore indirizza i piani di aggiornamento estesi. A livello funzionale l'operatore esegue ogni input in sequenza (dall'alto verso il basso). Ogni input è in genere un aggiornamento di un oggetto diverso. L'operatore restituisce soltanto le righe derivanti dall'ultimo input (inferiore). `Sequence` è un operatore logico e fisico.|  
|![Icona dell'operatore Sequence Project](../../2014/database-engine/media/sequence-project-32x.gif "Icona dell'operatore Sequence Project")|`Sequence Project`|Il `Sequence Project` operatore consente di aggiungere colonne per eseguire calcoli in un set ordinato. L'operatore divide il set di input in segmenti in base al valore di una o più colonne e quindi restituisce un segmento per volta. Tali colonne vengono visualizzate come argomenti nell'operatore `Sequence Project`. `Sequence Project` è un operatore logico e fisico.|  
|![Icona dell'operatore Snapshot per il cursore](../../2014/database-engine/media/snapshot-32x.gif "Icona dell'operatore Snapshot per il cursore")|**Snapshot**|L'operatore **Snapshot** crea un cursore che non consente di visualizzare le modifiche apportate da altri utenti.|  
|![Icona dell'operatore Sort](../../2014/database-engine/media/sort-32x.gif "Icona dell'operatore Sort")|`Sort`|Il `Sort` operatore Ordina tutte le righe in ingresso. Il `Argument` colonna contiene un DISTINCT predicato ORDER BY :() se tramite l'operazione vengono eliminati i duplicati oppure un predicato ORDER BY :() con un elenco delimitato da virgole delle colonne da ordinare. Alle colonne viene assegnato il prefisso ASC se sono ordinate in ordine crescente o il prefisso DESC se sono ordinate in ordine decrescente. `Sort` è un operatore logico e fisico.|  
|![Icona dell'operatore Split](../../2014/database-engine/media/split-32x.gif "Icona dell'operatore Split")|`Split`|Il `Split` operatore viene usato per ottimizzare l'elaborazione degli aggiornamenti. Ogni operazione di aggiornamento viene suddivisa in un'operazione di eliminazione e un'operazione di inserimento. `Split` è un operatore logico e fisico.|  
|![Icona dell'operatore Spool](../../2014/database-engine/media/spool-32x.gif "Icona dell'operatore Spool")|**Spool**|Il **Spool** operatore Salva risultati di query intermedi di `tempdb` database.|  
|![Icona dell'operatore Stream Aggregate](../../2014/database-engine/media/stream-aggregate-32x.gif "Icona dell'operatore Stream Aggregate")|`Stream Aggregate`|Il `Stream Aggregate` operatore Raggruppa le righe da una o più colonne e quindi calcola una o più espressioni di aggregazione restituite dalla query. L'output di questo operatore può essere utilizzato come riferimento da operatori successivi nella query, può essere restituito al client o può essere oggetto di entrambe le operazioni. Per l'operatore `Stream Aggregate` è necessario che l'input sia ordinato in base alle colonne all'interno del relativo gruppo. In Query Optimizer verrà utilizzato un operatore `Sort` prima di questo se i dati non sono già stati ordinati tramite un operatore `Sort` precedente o tramite una ricerca o un'analisi di un indice ordinato. Nell'istruzione SHOWPLAN_ALL o nel piano di esecuzione grafico in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], le colonne nel predicato GROUP BY sono elencate nel `Argument` colonna e le espressioni di aggregazione sono elencate nel **Defined Values** colonna. `Stream Aggregate` è un operatore fisico.|  
|![Icona dell'operatore Switch](../../2014/database-engine/media/switch-32x.gif "Icona dell'operatore Switch")|**Opzione**|**Switch** è un tipo speciale di iteratore di concatenazione che prevede *n* input. A ogni operatore **Switch** è associata un'espressione. In base al valore restituito dall'espressione (compreso tra 0 e *n*-1), l'operatore **Switch** copia il flusso di input appropriato nel flusso di output. Tra i possibili utilizzi dell'operatore **Switch** è inclusa l'implementazione di query che richiedono cursori fast forward con operatori specifici, ad esempio l'operatore **TOP** . **Switch** è un operatore logico e fisico.|  
|![Icona dell'operatore Table Delete](../../2014/database-engine/media/table-delete-32x.gif "Icona dell'operatore Table Delete")|`Table Delete`|Il `Table Delete` operatore fisico Elimina righe dalla tabella specificata nella `Argument` colonna del piano di esecuzione della query.|  
|![Icona dell'operatore Table Insert](../../2014/database-engine/media/table-insert-32x.gif "Icona dell'operatore Table Insert")|`Table Insert`|Il `Table Insert` operatore inserisce righe dal proprio input nella tabella specificata nella `Argument` colonna del piano di esecuzione della query. Il `Argument` colonna include inoltre un predicato SET :(), che indica il valore su cui è impostata ogni colonna. Se `Table Insert` sono disponibili figli per i valori insert, quindi la riga inserita verrà recuperata dall'operatore Insert stesso. `Table Insert` è un operatore fisico.|  
|![Icona dell'operatore Table Merge](../../2014/database-engine/media/table-merge-32x.gif "Icona dell'operatore Table Merge")|**Table Merge**|L'operatore **Table Merge** applica un flusso di dati di unione a un heap. L'operatore Elimina, aggiorna o inserisce righe nella tabella specificata nel `Argument` colonna dell'operatore. L'operazione effettiva eseguita dipende dal valore in fase di esecuzione del **azione** specificata nella colonna di `Argument` colonna dell'operatore. **Table Merge** è un operatore fisico.|  
|![Icona dell'operatore Table Scan](../../2014/database-engine/media/table-scan-32x.gif "Icona dell'operatore Table Scan")|`Table Scan`|Il `Table Scan` operatore recupera tutte le righe dalla tabella specificata nel `Argument` colonna del piano di esecuzione della query. Se una predicato WHERE :() nel `Argument` colonna, vengono restituite solo le righe che soddisfanno il predicato. `Table Scan` è un operatore logico e fisico.|  
|![Icona dell'operatore Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Icona dell'operatore Table Spool")|**Table Spool**|L'operatore **Table Spool** esegue l'analisi dell'input e inserisce una copia di ogni riga in una tabella di spooling nascosta archiviata nel database [tempdb](../relational-databases/databases/tempdb-database.md) e con durata limitata alla durata della query. Se l'operatore viene riavvolto (ad esempio, tramite un `Nested Loops` operator) ma non la riassociazione è necessaria, i dati di spooling viene usati invece di eseguire l'input. **Table Spool** è un operatore fisico.|  
|![Icona dell'operatore Table Update](../../2014/database-engine/media/table-update-32x.gif "Icona dell'operatore Table Update")|`Table Update`|Il `Table Update` operatore fisico Aggiorna le righe di input nella tabella specificata nel `Argument` colonna del piano di esecuzione della query. Il predicato SET:() determina il valore di ogni colonna aggiornata. Un riferimento a tali valori può essere presente nella clausola SET o in altri punti dell'operatore o nella query.|  
|![Icona dell'operatore Table-valued Function](../../2014/database-engine/media/table-valued-function-32x.gif "Icona dell'operatore Table-valued Function")|**Table-valued Function**|L'operatore **Table-valued Function** valuta una funzione con valori di tabella ( [!INCLUDE[tsql](../includes/tsql-md.md)] o CLR) e archivia le righe risultanti nel database [tempdb](../relational-databases/databases/tempdb-database.md) . Quando gli iteratori del padre richiedono le righe **Table-valued Function** restituisce le righe da `tempdb`.<br /><br /> Le query con chiamate a funzioni con valori di tabella generano piani di query con l'iteratore **Table-valued Function** . **Table-valued Function** può essere valutato con valori di parametri diversi:<br /><br /> **Table-valued Function XML Reader** specifica come parametro di input un BLOB XML e produce un set di righe che rappresentano i nodi XML nell'ordine di un documento XML. Altri parametri di input possono limitare i nodi XML restituiti a un subset di un documento XML.<br /><br /> **Table Valued Function XML Reader con filtro XPath** è un tipo speciale di **XML Reader Table-valued Function** che limita l'output ai nodi XML che soddisfano un'espressione XPath.<br /><br /> <br /><br /> **Table-valued Function** è un operatore logico e fisico.|  
|![Icona dell'operatore Top](../../2014/database-engine/media/top-32x.gif "Icona dell'operatore Top")|**Top**|L'operatore **Top** esegue l'analisi dell'input e restituisce solo il primo numero o valore percentuale di righe specificato, eventualmente in base a un ordinamento. Il `Argument` colonna può contenere un elenco delle colonne che si verifica la presenza di collegamenti. Nei piani di aggiornamento l'operatore **Top** consente di applicare limiti di conteggio righe. **Top** è un operatore logico e fisico. **Top** è un operatore logico e fisico.|  
|None|**Top N Sort**|**Top N Sort** è simile al `Sort` iteratori, ma richiede che solo le prime *N* righe sono necessari e non l'intero set di risultati. Per valori bassi di *N*, il motore di esecuzione delle query di [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] prova a eseguire l'intera operazione di ordinamento in memoria. Nel caso di valori elevati di *N*, il motore di esecuzione delle query ricorre al metodo di ordinamento più generico in cui *N* non corrisponde a un parametro.|  
|![Icona di operatore esteso (UDX)](../../2014/database-engine/media/udx-32x.gif "Icona di operatore esteso (UDX)")|`UDX`|Gli operatori estesi (UDX) implementano una delle varie operazioni XQuery e XPath in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Tutti gli operatori UDX sono logici e fisici.<br /><br /> Operatore esteso (UDX) `FOR XML` viene utilizzato per serializzare gli input nella rappresentazione XML in un'unica colonna BLOB in un'unica riga di output del set di righe relazionale. È un operatore di aggregazione XML sensibile all'ordinamento.<br /><br /> L'operatore esteso (UDX) `XML SERIALIZER` è un operatore di aggregazione XML sensibile all'ordinamento. Inserisce righe che rappresentano nodi XML o valori scalari XQuery nell'ordine dei documenti XML e genera un BLOB XML serializzato in un'unica colonna XML in una singola colonna di output.<br /><br /> L'operatore esteso (UDX) `XML FRAGMENT SERIALIZER` è un particolare tipo di `XML SERIALIZER` utilizzato per l'elaborazione delle righe di input che rappresentano frammenti XML da inserire nell'estensione INSERT di XQuery per la modifica di dati.<br /><br /> L'operatore esteso (UDX) `XQUERY STRING` valuta il valore stringa XQuery delle righe di input che rappresentano i nodi XML. È un operatore di aggregazione di stringa sensibile all'ordinamento. Restituisce come output una riga con colonne che rappresentano il valore scalare XQuery che include il valore stringa dell'input.<br /><br /> L'operatore esteso (UDX) `XQUERY LIST DECOMPOSER` è un operatore di scomposizione di elenco XQuery. Per ogni riga di input che rappresenta un nodo XML, genera una o più righe, ognuna delle quali rappresenta un valore scalare XQuery che include un valore di voce di elenco se l'input è di tipo elenco XSD.<br /><br /> L'operatore esteso (UDX) `XQUERY DATA` valuta la funzione XQuery fn:data() rispetto all'input che rappresenta i nodi XML. È un operatore di aggregazione di stringa sensibile all'ordinamento. Restituisce come output una riga con colonne che rappresentano il valore scalare XQuery che include il risultato di **fn:data()**.<br /><br /> L'operatore esteso `XQUERY CONTAINS` valuta la funzione XQuery fn:contains() rispetto all'input che rappresenta i nodi XML. È un operatore di aggregazione di stringa sensibile all'ordinamento. Restituisce come output una riga con colonne che rappresentano il valore scalare XQuery che include il risultato di **fn:contains()**.<br /><br /> Operatore esteso `UPDATE XML NODE` aggiorna il nodo XML nell'espressione XQuery estensione di modifica di dati in sostituzione la **Modify ()** metodo sul tipo XML.|  
|None|**Union**|L'operatore **Union** esegue l'analisi di più input e restituisce ogni riga sottoposta ad analisi rimuovendo i duplicati. L'operatore**Union** è un operatore logico.|  
|![Icona dell'operatore Update (motore di database)](../../2014/database-engine/media/update-32x.gif "Icona dell'operatore Update (motore di database)")|`Update`|Il `Update` operatore Aggiorna ogni riga dal proprio input nell'oggetto specificato nel `Argument` colonna del piano di esecuzione della query. `Update` è un operatore logico. L'operatore fisico è `Table Update`, `Index Update` o `Clustered Index Update`.|  
|![Icona dell'elemento di linguaggio While](../../2014/database-engine/media/while-32x.gif "Icona dell'elemento di linguaggio While")|`While`|Il `While` operatore implementa il [!INCLUDE[tsql](../includes/tsql-md.md)] ciclo while. `While` è un elemento di linguaggio|  
|![Icona dell'operatore Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Icona dell'operatore Table Spool")|`Window Spool`|L'operatore `Window Spool` espande ogni riga nel set di righe che rappresenta la finestra associata. In una query la clausola OVER definisce la finestra all'interno di un set di risultati della query, quindi una funzione della finestra calcola un valore per ogni riga della finestra stessa. `Window Spool` è un operatore logico e fisico.|  
  
  
